\chapter{Conclusion}\label{eicfg-conclusion}
Many \Cpp\ programs exhibit exceptional control flow that standard \ac{cfg} extraction tools in disassemblers and decompilers do not identify.
To deal with that issue, we have provided \acp{eicfg} and a tool for generating them.
\acp{eicfg} extend standard \acp{cfg} extracted from binaries by including nodes and edges for exceptional control flow.
Our abstract transition relation for exceptional control flow has been informally shown to overapproximate the concrete versions of those edges.
Furthermore, we have applied our \ac{eicfg} generator to \totalbins\ real-world programs and libraries.
We identified \uniquethrows\ unique throws and were able to trace each one's exceptional control flow: \caughtthrows\ were potentially caught while \uncaughtthrows\ had no identified potential for being caught.
On average, dealing with exceptional control flow can increase coverage by \avgdiffinst\ per unique throw, with each throw averaging \avgunwinds\ unwind edges.
Those edges are ones tools such as Ghidra do not produce.
%\satisfactorybins\ of which were analyzed in a satisfactory manner (\cutoffpercent\ coverage).
%On average, we achieved \coveredpercent\ coverage.

\section{Comparison with our Previous Work}
\todo{flesh this out}

\section{Limitations}
One of the main drawbacks of our work is a propensity for state space explosion.
While we were able to target programs with over \num{400000} instructions,
our \acp{eicfg} generally do not scale far beyond that. Even for smaller programs, we experienced timeouts and out-of-memory cases when a significant number of control flow nodes and edges were generated.
Methods of reducing the state space while maintaining interprocedural exceptional analysis would provide for increased scalability and the ability to target even larger programs.
For example, modeling of exception type info and integrating it into the $\landingpadtable$ determinations would allow pruning of dead branches, reducing the tool's overapproximation.
% Wanted to use this to begin with but I couldn't get types table parsing fully working right

The other main drawback lies with stripped programs that do not perform indirect calls or jumps, but do pass non-immediate values to external or internal calls.
Dealing with this requires significant manual modeling in our current approach.
Additional heuristics for identifying possible function entry points \autocite{bao2014byteweight,pe2020probabilistic}
may help with this drawback.

Finally, unresolved indirections are also an issue, particularly in stripped binaries.
Better jump table heuristics \autocite{cifuentes2001recovery,flexeder2010reconstruction,gedich2015switch,an2022dsv}
may result in less false positives/negatives for jump table calculations without the need for manual tuning.
This issue may also benefit from additional function entry heuristics as well,
as they would allow per-function fallbacks in the presence of unresolved jumps even without function symbols.

While we deal with structured \Cpp\ exceptions, we do not provide support for interrupt-based exception handling.
Semantics are not provided for interrupt-triggering instructions; they are instead treated as no-ops.
We also do not deal with concurrency.
