\chapter{Lattice-Based Formal Lifting and \aclp*{hg}}\label{ch:lattice-lifting}

\Ac{hg}

\section{Properties of Interest}

\section{Assumptions and Scope}

\section{Example}

\section{Technical Formulation}
\todo{copy the stuff over here. Wonder if I'll end up making this long enough to be it's own chapter?}

\subsection{Predicates}
\emph{Predicates}\index{state!predicate} are assertions on state.
A predicate~$P$\nomenclature{$P$}{A state predicate}
consists of a set of \emph{clauses}\index{state!predicate!clause}.
$P$ holds in state~$s$%
\nomenclature{$s$}{A concrete state \todo{give better clarification for this elative to the Hoare Graphs}} if and only if all clauses hold.
This is indicated with notation \todo{Did we use explicit notation for this?}.

\todo{maybe put more here? Connect to logical predicates}

Breaking it down further, a clause consists of two symbolic expressions\index{symbolic!expression}
and their relation.
A symbolic expression of type $\expression$%
\nomenclature{$\expression$}{Type of symbolic expressions for \ac{hg} work}
consists of the some combination of the following:
\begin{itemize}
  \item register references ($\register$),%
  \nomenclature{$\register$}{Type of symbolic registers}%
  \index{symbolic!register}
  \item flag references ($\flag$),\nomenclature{$\flag$}{Type of symbolic flags}%
  \index{symbolic!flag}
  \item 64-bit words ($\word$),\index{number!word}
  \item symbolic values ($\val$),%
  \nomenclature{$\val$}{Type of symbolic values for \ac{hg} work}%
  \index{symbolic!value}
  \item memory regions (modeled by an expression for the address and a natural number\index{number!natural} for the size)%
  \index{symbolic!memory!region}, and
  \item the application of an operator\index{symbolic!operator}
  to a list of expressions.
\end{itemize}
In data type notation, this is:
\begin{equation}
  \expression\coloneqq
  \register\mid
  \flag\mid
  \word\mid
  \val\mid
  \expression\times\nat\mid
  \mathsf{Op}\times[\expression]
\end{equation}%
\nomenclature{$\coloneqq$}{Indicates the right-hand side defines the left-hand side for \ac{hg} and \ac{eicfg} work}
We identify a subset of these symbolic expressions called \emph{constant expressions} ($\constant$).%
\nomenclature{$\constant$}{Type of constant expressions}%
\index{constant!expession}
These expressions cannot contain state parts such as registers, flags, or memory regions.
They represent constants or computations constructed using initial values.
For example, $\reg{rdi}_0$ denotes the initial symbolic value of register $\reg{rdi}$.
% TODO: This should probably be nomenclature somehow but I'm not sure how
This value does not change during symbolic execution.

\todo{made it to here on my revisions for today\dots slow work, but at least I'm making progress, I guess?}

Clauses are terms of the form $\expression \mathbin{\square} \constant$,
where $\square$ is an element of the following set of relations:
$\{=,\neq,<,<_s,\ge,\ge_s\}$.
The $\square_s$ relations treat their operands as signed,
while their non-subscripted versions treat their operands as unsigned.
There are two special predicates, $\top$ and $\bot$,
that respectively indicate being always true and always false.
$\bot$ is also used to indicate an unknown $\constant$.
\begin{definition}\label{def:join}
  The join of two predicates~$P$ and~$Q$, notation $P\sqcup Q$, is defined as:
  \begin{align*}
    P\sqcup Q &\defeq \bigcup\{\merge(p,q) \mid \langle p,q\rangle\in P\times Q\} \\
    \merge(l=r_1,l=r_2) &\defeq \{l\ge\min(r_1,r_2),l\le\max(r_1,r_2)\} \\
    \merge(l<r_1,l<r_2) &\defeq \{l<\max(r_1,r_2)\} \\
    &\vdots\\
    \merge(a,b) &\defeq
    \begin{cases}
      \{a\} & \text{if }a=b \\
      \varnothing & \text{otherwise}
    \end{cases}
  \end{align*}
\end{definition}
The operator presented in \cref{def:join}
performs a \emph{merge} for each clause pair $\langle p,q\rangle$
in the Cartesian product of its argument predicates.
This merge produces a potentially empty set of clauses
generated from the two clauses supplied to it.
% The union of all sets produced is then taken, resulting in the joined predicate.
While only merge rules for $=$ and $<$ are shown, there are also rules
for the other possible clause operations.
The $\max$ and $\min$ functions used are partial;
they do not have a result
if the maximum/minimum of the expressions supplied to them cannot be determined.
This can happen if those symbolic expressions contain variables.
In such cases, no clause is produced.
%The supremum, repeated join over a set of predicates, is denoted by $\bigsqcup\square$. % do we even have a supremum here anymore?

\begin{example}
  Let $P=\{a=3,a<\reg{rdi}_0\}$ and $Q=\{a=4,a<\reg{rsi}_0\}$.
  As both predicates have equality clauses for~$a$, those clauses are merged to produce a pair of clauses denoting that the value of $a$ lies in the range $[3,4]$.
  Since no maximum can be established between $\reg{rdi}_0$ and $\reg{rsi}_0$, these clauses are dropped.
  Thus, $P\sqcup Q=\{a\ge 3,a\le4\}$.
\end{example}

As required for a lattice, the join is associative, commutative and idempotent.
Associativity is derived from the fact that set union and minimum/maximum are associative operations.
The join is commutative and idempotent due to the commutativity and idempotency of the merge function.
\begin{lemma}\label{lem:pred_soundness}
  For any state~$s$: $s\vdash  P\vee Q\implies s\vdash P\sqcup Q$
\end{lemma}

\subsection{Memory Models}

\subsubsection{???}

\subsubsection{Insertion}
