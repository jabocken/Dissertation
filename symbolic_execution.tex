\chapter{Memory Usage}\label{ch:symbolic_execution}

% planning:
% - Machine Model
% - Memory aliasing
% -- describe problem (SPLSA)
% -- separation/enclosure
% -- Readmem
% - Rewriting
% -- Isabelle rules
% -- ...

% Fix up prologue/preamble, give overview and outline

Symbolic execution, in a sense,%
\index{symbolic execution}
is an extension of symbolic manipulation of mathematical equations.
It involves executing a program with a set of symbolic inputs
rather than concrete values~\citep{king1976symbolic}.
The individual steps of execution are implemented as \emph{rewrite rules}%
\index{symbolic execution!rewrite rule}
over the state.
When used in a theorem prover such as Isabelle/HOL,
those rules are ideally proven to be correct.

In order to perform symbolic execution, you must have some sort of \emph{machine model}.%
\index{symbolic execution!machine model}

\section{Machine Model}\label{se:machine_model}
The machine model used in this dissertation%
\index{symbolic execution!machine model}
is an extension of the work of \citet{roessle2019}.
They embedded bitvector-based, machine-learned semantics
of a modern version of the x86-64 \ac{isa},
which includes instruction set extensions such as the \ac{sse} family, in Isabelle/HOL.
To improve reliability of their work,
it was tested against an actual, live x86-64 machine to prove semantic equivalence.
The semantics they used was an extension of that
provided by \citet{heule2016stratified},
who applied machine learning to derive semantics from a physical machine as well.
This produced highly reliable semantics:
they formally compared a subset of their automatically-generated semantics
to manually written rules based on the Intel reference manuals
and found that in the few cases where they differed, the Intel manuals were wrong.
Note that this model does not include concurrency.

The model is structured as follows.
It has some symbolic \emph{state} defined as an Isabelle record
that stores registers, flags, and 64-bit addressable byte-level memory.
The memory holds both instructions and data, as in the standard von Neumann model.%
\index{von Neumann model}
Each instruction is executed by a \emph{step} function,%
\index{symbolic execution!step function}




% TODO

As the x86-64 \ac{isa} is a little-endian architecture,%
\index{endianness!little}
all operations on memory presented in this dissertation are designed with that in mind.
\begin{example}
  Given the state $\{\region{a}2\coloneqq\mathtt{0xEEFF}\}$,
  a read of region $\region{a}1$ would produce $\mathtt{0xFF}$.
\end{example}
Support for big-endian architectures would require changing how reads and writes%
\index{endianness!big}
are performed. For every read and write, the bytes would need to be reversed
in order to use them appropriately.
Some \acp{isa} are even \emph{bi-endian}, allowing both big- and little-endian%
\index{endianness!bi}
memory operations. These include modern versions of ARM, PowerPC, SPARC, and MIPS.
Supporting bi-endianness would require additional complexity in memory handling.

\subsection{Restrictions of the Model}
The usage of a shared data space for instructions and data, though very common,
does involve some issues for verification.
The model does not currently provide any memory protection schemes,%
\index{memory!protection}
such as those used in modern hardware,
and there is nothing to prevent a write from overwriting the program itself.
For that reason,
the works presented in this document assume that the loaded assembly is never modified.

\section{Symbolic Execution and Memory Usage}
% TODO: probably need more here
Symbolic execution in Haskell keeps track of all used memory regions,%
\index{symbolic execution}
both the actual regions used by instructions as well as merged regions.
\begin{example}\label{ex:simple}
  Consider the following x86-64 assembly block:
  \begin{lstlisting}[style=x64,gobble=4]
    a0: mov    word ptr [rsp-0x8], 0xEEFF
    a1: mov    dword ptr [rsp-0x4], 0xAABBCCDD
    a2: mov    ax, word ptr [rsp-0x7]
    a3: mov    edi, dword ptr [rsp-0x6]
  \end{lstlisting}
  The instructions at addresses~\lstinline|a0| and~\lstinline|a1|
  write to two separate regions in memory,
  $r_0=\region{\mathrsp-8}2$ and $r_1=\region{\mathrsp-4}4$.
  Following the writes, the instruction at \lstinline|a2|
  reads from region $\region{\mathrsp-7}{2}$,
  which is merged with~$r_0$ to obtain $r_2=\region{\mathrsp-8}3$.
  Reading from region $\region{\mathrsp-6}4$
  results in a merge with~$r_2$ and~$r_1$, producing region $\region{\mathrsp-8}8$.
  The aggregated assignment is then
  \begin{equation*}
    \region{\mathrsp-8}{8}\coloneqq\mathtt{0xAABBCCDD}\concat
    \takebits{31,16}\readmem{\mathrsp-8}{8}\concat\mathtt{0xEEFF}.
  \end{equation*}
  The set~$M$ of memory regions for the given block of assembly is ultimately
  \begin{equation*}
    M\equiv\{\region{\rspo-8}2,\region{\rspo-4}4,\region{\rspo-7}2,
    \region{\rspo-6}4,\region{\rspo-8}8\}.
  \end{equation*}
\end{example}

\subsection{Memory Aliasing}\label{sse:memory_aliasing}
This section provides an insight into the issue of \emph{memory aliasing}.%
\index{memory!aliasing}
For example, consider a write to memory region $\region{a_1}{s_1}$
using the preexisting set of assignments $\{\region{a_0}{s_0}\coloneqq v_0\}$.
The aggregated result of that set of assignments
depends on whether the two regions $\region{a_0}{s_0}$ and $\region{a_1}{s_1}$
overlap, are \emph{separate}, or have an \emph{enclosure} relation.%
\index{memory!region!separation}%
\index{memory!region!enclosure}
\begin{definition}
  Two regions $r_0=\region{a_0}{s_0}$ and $r_1=\region{a_1}{s_1}$ are \emph{separate},
  notation $r_0\bowtie r_1$, if and only if
  \begin{equation*}
    s_0=0\vee s_1=0\vee a_0+s_0\leq a_1\vee a_1+s_1\leq a_0.
  \end{equation*}
  If those regions are not separate, they \emph{overlap}.
\end{definition}
\begin{example}
  \todo{concrete example}
\end{example}
\begin{definition}
  Region $r_0$ is \emph{enclosed} by $r_1$, notation $r_0\sqsubseteq r_1$,
  if and only if
  \begin{equation*}
  a_0\geq a_1\wedge a_0+s_0\leq a_1+s_1.
  \end{equation*}
\end{definition}
\begin{example}
  \todo{concrete example}
\end{example}

An additional problem is when a region that overlaps with at least one other region
that has been modified is written to.
To combine those writes, the regions must be \emph{merged}.%
\index{memory!merging}
\begin{definition}\label{def:merge}
  The \emph{merge} of two symbolic assignments
  $r_0=\region{a_0}{s_0}\coloneqq v_0$ and $r_1=\region{a_1}{s_1}\coloneqq v_1$,
  where the write to~$r_1$ occurs before the write to~$r_0$,
  is defined as $r=\region{a}s\coloneqq b_0\concat b_1\concat b_2$, where:
  \nomenclature{$\bullet$}{Indicates bitstring concatenation}
  \begin{align*}
  i_0 &= a_0 - a_1 \\
  i_1 &= a_1 + s_1 - (a_0 + s_0) \\
  a   &= \text{if } i_0 < 0 \text{ then } a_0 \text{ else } a_1 \\
  s   &= s_0 + \max(i_0, 0) + \max(i_1, 0) \\
  b_0 &= \text{if } i_1 > 0 \text{ then }
  \takebits{8 s_1-1,8 s_1 - 8 i_1}v_1 \text{ else } 0_0 \\
  b_1 &= \takebits{8 s-1, 0} v_0 \\
  b_2 &= \text{if } i_0 > 0 \text{ then } \takebits{8 i_0-1, 0}v_1 \text{ else } 0_0
  \end{align*}
\end{definition}
As the merged region must encompass both original regions,
its address~$a$ is the minimum of~$a_0$ and~$a_1$.
The value stored in the merged region consists of three parts:
whatever portion of~$v_1$, if any, is below~$a_0$;
a possibly zero-extended~$v_0$;
and the part of~$v_1$ above $a_0+s_0$ (the upper bound of~$r_0$),
if there are any bits in~$r_1$ above that address.
For sets of assignments such as those mentioned above,
merge is used as an infix operator, with order being important
(the first assignment overwrites [parts of] the second as shown above).

Writing to and reading from memory in the process of symbolic execution
also requires analysis of separation and merging.
Consider reading from the region $\region{a}{s}$ given a set of assignments~$\alpha$,
using \cref{algo:mem_read} as our guide.
\begin{algorithm}
  \caption{Symbolically reading from memory}\label{algo:mem_read}
  \begin{algorithmic}
    \Require{A symbolic region $\region{a}{s}$}
    \Ensure{A symbolic value}
    \Comment{Possibly updates the current set of assignments $\alpha:A_\var{SP}$}
    \Function{read\_mem}{$\region{a}{s}$}
      \If{$\exists v\cdot(\region{a}{s}\coloneqq v)\in\alpha$}
        \State\Return $v$
      \Else
        \State $\var{ovl}\gets\{(\region{a'}{s'}\coloneqq v)\in
        \alpha\mid\region{a'}{s'}\not\bowtie\region{a}{s}\}$
        \State $\var{sep}\gets\{(\region{a'}{s'}\coloneqq v)\in
        \alpha\mid\region{a'}{s'}\bowtie\region{a}{s}\}$
        \State $\region{a_l}{s_l},\region{a_r}{s_r}\gets
        \text{the left- and rightmost regions in }\{\region{a}{s}\}\cup\var{ovl}$
        \State $r\gets\region{a_l}{a_r-a_l+s_r}$
        \State $\region{a'}{s'}\coloneqq v'\gets
        \var{ovl}_0\mmerge\var{ovl}_1\mmerge\ldots\mmerge(r\coloneqq *r)$
        \State $\alpha\gets\{\region{a'}{s'}\coloneqq v'\}\cup\var{sep}$
        \State $a''\gets8(a-a')-1$
        \State\Return $\takebits{s+a'',a''}v'$
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}
If an assignment to the exact region $\region{a}{s}$
exists in the current set of assignments,
then the value assigned to that region,~$v$, is returned.
Otherwise, the algorithm must consider the set of assignments
for all possibly overlapping and necessarily separated regions.
One single assignment that accounts for all overlapping regions must be developed.
To do this, the leftmost and rightmost overlapping regions are considered.
These regions are defined as the regions that start at the smallest address~$a_l$
and end at the greatest upper bound $a_r+s_r$, respectively.
The new region~$r$ has address~$a_l$ and size $a_r-a_l+s_r$.
All of the overlapping regions are then merged into one single assignment based on~$r$,
starting with the trivial assignment $r\coloneqq *r$.
This assignment does nothing but set up the merging,
as it writes the value read from region~$r$ back to that same region.
After merging, the current set of assignments is updated to be the merged region
and assignment combined with all separate assignments.
The final value read from memory is extracted from the merged assignment.
Writing to memory occurs in a similar fashion.

\section{Summary}
