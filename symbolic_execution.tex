\chapter{Symbolic Execution}\label{ch:symbolic_execution}
% Fix up prologue/preamble, give overview and outline

Symbolic execution, in a sense,%
\index{symbolic execution}
is an extension of symbolic manipulation of mathematical equations.
It involves executing a program with a set of symbolic inputs
rather than concrete values~\citep{king1976symbolic}.
The individual steps of execution are implemented as \emph{rewrite rules}%
\index{symbolic execution!rewrite rule}
over the state.
When used in a theorem prover such as Isabelle/HOL, those rules can be proven correct.
Applying those rules in sequence to each step or instruction of a program
allows aggregation of the individual state changes involved in the execution.

As an example of how the aggregation works, consider the following two instructions:
\begin{lstlisting}[style=x64, gobble=2]
  xor eax, eax
  add al, 1
\end{lstlisting}
These instructions write to the 64-bit register \inlineasm{rax}.
Registers \inlineasm{eax} and \inlineasm{al} respectively refer
to the low 32 and 8 bits of that register.
Symbolic execution produces the following assignment:
$\mathrax\coloneqq\takebits{63,32}\mathrax\concat 1_{32}$.
Here $\takebits{63,32}$ denotes taking the higher 32 bits%
\nomenclature{$\takebits{h,l}w$}{Indicates taking bits in word~$w$
  from bit~$l$ to bit~$h$ using 0-indexing}
and~$\concat$ denotes concatenation,%
\nomenclature{$\concat$}{Indicates bitstring concatenation}
with $1_{32}$ being the number one zero-extended to~32 bits.
The \inlineasm{xor} instruction sets the lower~$32$ bits of the register to zero
while \inlineasm{add} increments the lower byte by one.
Both instructions keep the higher~32 bits intact.
The aggregate result is overwriting the lower~32 bits of the register
with the 32-bit representation of one.

\section{Machine Model}\label{se:machine_model}
In order to perform symbolic execution,
you must first have some sort of \emph{machine model}.%
\index{symbolic execution!machine model}
The machine model used in this dissertation for the work in Isabelle/HOL
is an extension of the work of \citet{roessle2019}.
They embedded bitvector-based, machine-learned semantics
of a modern version of the x86-64 \ac{isa},
which includes instruction set extensions such as the \ac{sse} family, in Isabelle/HOL.
To improve reliability of their work,
it was tested against an actual, live x86-64 machine to prove semantic equivalence.
The semantics they used was an extension of that provided by \citet{heule2016stratified},
who did the initial application of machine learning
to derive semantics from a physical machine.
This produced highly reliable semantics:
they formally compared a subset of their automatically-generated semantics
to manually written rules based on the Intel reference manuals
and found that in the few cases where they differed, the Intel manuals were wrong.
Note that this model does not include concurrency.

The model is structured as follows.
It has some symbolic \emph{state} defined as an Isabelle record
that stores registers, flags, and 64-bit addressable byte-level memory.
The memory holds both instructions and data, as in the standard von Neumann model.%
\index{von Neumann model}
Each instruction is executed by a \emph{step} function,%
\index{symbolic execution!step function}
defined to suit the nature of the symbolic execution engine in use.
The works presented in this dissertation in \cref{ch:cfg,ch:syntax}
each use their own, slightly different symbolic execution engine,
though the ultimate behavior is executing a sequence of instructions one by one,
modifying the state each time.

The instructions themselves are loaded from the machine model
by mapping from the deeply-embedded instruction representation
extracted within or supplied to the step function
to the bitvector formulas provided by \citet{roessle2019}.
If no such formula exists for the current instruction,
a manually-implemented variant is used.
There are several sets of instructions
that are guaranteed to only have manual implementations due to limitations
of the machine learning setup, with the major ones being
jumps, \inlineasm{call}, \inlineasm{push}, \inlineasm{pop}, \inlineasm{enter},
\inlineasm{leave}, and \inlineasm{ret}.

\subsection{Restrictions of the Model}
As the x86-64 \ac{isa} is a little-endian architecture,%
\index{endianness!little}
all operations on memory presented in this dissertation are designed with that in mind.
\begin{example}
  Given the state $\sigma=\{\region{a}2\coloneqq\mathtt{0xEEFF}\}$,
  the read $\readmemS\sigma{a}1$ would produce $\mathtt{0xFF}$.
\end{example}
Support for big-endian architectures would require changing how reads and writes%
\index{endianness!big}
are performed, as both the formal Isabelle and informal Haskell models
assume little-endianness in their implementation.
Some \acp{isa} are even \emph{bi-endian}, allowing both big- and little-endian%
\index{endianness!bi}
memory operations. These include modern versions of ARM, PowerPC, SPARC, and MIPS.
Supporting bi-endianness would require additional complexity in memory handling.

Additionally,
the usage of a shared data space for instructions and data, though very common,
does involve some issues for verification.
The model does not currently provide any memory protection schemes,%
\index{memory!protection}
such as those used in modern hardware,
and there is nothing to prevent a write from overwriting the program itself.
For that reason,
the works presented in this document assume that the loaded assembly is never modified.

\subsection{Simplification Rules}\label{se:simplification}
The basic rules supplied by the machine model are not well-suited to verification;
they are often very low-level bitvector/bitstring operations.
While \citet{roessle2019} provided a large set of simplification rules
to abstract away from the underlying representation,
those rules did not cover all situations encountered in this dissertation,
requiring the additions of more such rules during the process of verification.

Additionally, to increase performance,
every instruction variant with learned semantics that is known to be in use
was given a \emph{presimplified} lemma.%
\index{presimplification}
These lemmas provide immediate abstractions of the low-level instruction representations
that rely on the aforementioned simplification rules.
Using these lemmas improved performance when performing symbolic execution,
as they greatly reduce the number of simplification rules that must be applied.

\section{Memory Aliasing}\label{sse:memory_aliasing}
This section provides an insight into the issue of \emph{memory aliasing}.%
\index{memory!aliasing}
For example, consider the assignment $\region{a_1}{s_1}\coloneqq v_1$
applied to the set of assignments $A=\{\region{a_0}{s_0}\coloneqq v_0\}$.
The result of that operation
depends on whether the two regions $\region{a_0}{s_0}$ and $\region{a_1}{s_1}$
\emph{overlap}, are \emph{separate}, or have an \emph{enclosure} relation.%
\index{memory!region!separation}%
\index{memory!region!enclosure}%
\index{memory!region!overlap}
If they are separate, then the resultant minimal assignment set is
$A'=\{\region{a_0}{s_0}\coloneqq v_0,\region{a_1}{s_1}\coloneqq v_1\}$.
If they instead overlap, then the situation is more complicated.
For example, in the case where $a_0=a_1$ and $s_0=s_1$,
the resultant minimal assignment set would be $A'=\{\region{a_0}{s_0}\coloneqq v_1\}$.
Other forms of overlap or enclosure, such as writing two bytes to a four byte region
or to regions that are not aligned, require even more complicated reasoning.

The actual definitions of those relations are as follows.
\begin{definition}[Separation]
  Two regions $r_0=\region{a_0}{s_0}$ and $r_1=\region{a_1}{s_1}$ are \emph{separate},
  notation $r_0\separate r_1$, if and only if the following is true:
  \begin{equation*}
    s_0=0\vee s_1=0\vee a_0+s_0\leq a_1\vee a_1+s_1\leq a_0.
  \end{equation*}
  If those regions are not separate, they \emph{overlap}.
\end{definition}
\begin{example}
  Consider the simple regions $r_0=\region{5}{4}$ and $r_1=\region{7}{4}$.
  Calculating separation for those two regions is as follows:
  \begin{gather*}
    4=0\vee 4=0\vee 5+4\leq 7\vee 7+4\leq 5 \\
    9\leq 7\vee 11\leq 5 \\
    \false\vee\false \\
    \false
  \end{gather*}
  Thus, those two regions are \emph{not} separate.
\end{example}

\begin{definition}[Enclosure]
  Region $r_0$ is \emph{enclosed} by $r_1$, notation $r_0\enclosed r_1$,
  if and only if:
  \begin{equation*}
    a_0\geq a_1\wedge a_0+s_0\leq a_1+s_1.
  \end{equation*}
\end{definition}
\begin{example}
  Consider the simple regions $r_0=\region{7}{4}$ and $r_1=\region{5}{8}$.
  Calculating enclosure for those two regions is as follows:
  \begin{gather*}
    7\geq 5\wedge 7+4\leq 5+8 \\
    7\geq 5\wedge 11\leq 13 \\
    \true\wedge\true \\
    \true
  \end{gather*}
  Thus~$r_1$ encloses~$r_0$.
\end{example}

\todo{This is a rewrite rule}
An additional problem is when a region that overlaps with at least one other region
that has been modified is written to.
To combine those writes, the regions must be \emph{merged}.%
\index{memory!merging}
\begin{definition}[Merging]\label{def:merge}
  The \emph{merge} of two symbolic assignments
  $r_0=\region{a_0}{s_0}\coloneqq v_0$ and $r_1=\region{a_1}{s_1}\coloneqq v_1$,
  where the write to~$r_1$ occurs before the write to~$r_0$,
  is defined as
  \begin{equation}
    r=\region{a}s\coloneqq b_0\concat b_1\concat b_2,
  \end{equation}
  where:
  \begin{align*}
  i_0 &= a_0 - a_1 \\
  i_1 &= a_1 + s_1 - (a_0 + s_0) \\
  a   &= \text{if } i_0 < 0 \text{ then } a_0 \text{ else } a_1 \\
  s   &= s_0 + \max(i_0, 0) + \max(i_1, 0) \\
  b_0 &= \text{if } i_1 > 0 \text{ then }
  \takebits{8 s_1-1,8 s_1 - 8 i_1}v_1 \text{ else } 0_0 \\
  b_1 &= \takebits{8 s-1, 0} v_0 \\
  b_2 &= \text{if } i_0 > 0 \text{ then } \takebits{8 i_0-1, 0}v_1 \text{ else } 0_0
  \end{align*}
\end{definition}
As the merged region must encompass both original regions,
its address~$a$ is the minimum of~$a_0$ and~$a_1$.
The value stored in the merged region consists of three parts:
whatever portion of~$v_1$, if any, is below~$a_0$;
a possibly zero-extended~$v_0$;
and the part of~$v_1$ above $a_0+s_0$ (the upper bound of~$r_0$),
if there are any bits in~$r_1$ above that address.
For sets of assignments such as those mentioned above,
merge is used as an infix operator, with order being important
(the first assignment overwrites [parts of] the second as shown above).
\Cref{ex:simple} demonstrates a more concrete usage of merging.

Writing to and reading from memory in the process of symbolic execution
also requires analysis of separation and merging.
Consider reading from the region $\region{a}{s}$ given a set of assignments~$\alpha$,
using \cref{algo:mem_read} as our guide.
\begin{algorithm}
  \caption{Symbolically reading from memory}\label{algo:mem_read}
  \begin{algorithmic}
    \Require{A symbolic region $\region{a}{s}$}
    \Ensure{A symbolic value}
    \Comment{Possibly updates the current set of assignments $\alpha:A_\var{SP}$}
    \Function{read\_mem}{$\region{a}{s}$}
      \If{$\exists v\cdot(\region{a}{s}\coloneqq v)\in\alpha$}
        \State\Return $v$
      \Else
        \State $\var{ovl}\gets\{(\region{a'}{s'}\coloneqq v)\in
        \alpha\mid\region{a'}{s'}\not\separate\region{a}{s}\}$
        \State $\var{sep}\gets\{(\region{a'}{s'}\coloneqq v)\in
        \alpha\mid\region{a'}{s'}\separate\region{a}{s}\}$
        \State $\region{a_l}{s_l},\region{a_r}{s_r}\gets
        \text{the left- and rightmost regions in }\{\region{a}{s}\}\cup\var{ovl}$
        \State $r\gets\region{a_l}{a_r-a_l+s_r}$
        \State $\region{a'}{s'}\coloneqq v'\gets
        \var{ovl}_0\mmerge\var{ovl}_1\mmerge\ldots\mmerge(r\coloneqq *r)$
        \State $\alpha\gets\{\region{a'}{s'}\coloneqq v'\}\cup\var{sep}$
        \State $a''\gets8(a-a')-1$
        \State\Return $\takebits{s+a'',a''}v'$
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}
If an assignment to the exact region $\region{a}{s}$
exists in the current set of assignments,
then the value assigned to that region,~$v$, is returned.
Otherwise, the algorithm must consider the set of assignments
for all possibly overlapping and necessarily separated regions.
One single assignment that accounts for all overlapping regions must be developed.
To do this, the leftmost and rightmost overlapping regions are considered.
These regions are defined as the regions that start at the smallest address~$a_l$
and end at the greatest upper bound $a_r+s_r$, respectively.
The new region~$r$ has address~$a_l$ and size $a_r-a_l+s_r$.
All of the overlapping regions are then merged into one single assignment based on~$r$,
starting with the trivial assignment $r\coloneqq *r$.
This assignment does nothing but set up the merging,
as it writes the value read from region~$r$ back to that same region.
After merging, the current set of assignments is updated to be the merged region
and assignment combined with all separate assignments.
The final value read from memory is extracted from the merged assignment.
Writing to memory occurs in a similar fashion.

\begin{example}[Merging]\label{ex:simple}
  Consider the following x86-64 assembly block:
  \begin{lstlisting}[style=x64, gobble=4]
  a0: mov  word ptr [rsp-0x8], 0xEEFF
  a1: mov dword ptr [rsp-0x4], 0xAABBCCDD
  a2: mov  ax,                  word ptr [rsp-0x7]
  a3: mov edi,                 dword ptr [rsp-0x6]
  \end{lstlisting}
  The instructions at addresses~\lstinline|a0| and~\lstinline|a1|
  write to two separate regions in memory,
  $r_0=\region{\mathrsp-8}2$ and $r_1=\region{\mathrsp-4}4$.
  Following the writes, the instruction at \lstinline|a2|
  reads from region $\region{\mathrsp-7}{2}$,
  which is merged with~$r_0$ to obtain $r_2=\region{\mathrsp-8}3$.
  Reading from region $\region{\mathrsp-6}4$
  results in a merge with~$r_2$ and~$r_1$, producing region $\region{\mathrsp-8}8$.
  The aggregated assignment is then
  \begin{equation*}
    \region{\mathrsp-8}{8}\coloneqq\mathtt{0xAABBCCDD}\concat
    \takebits{31,16}\readmem{\mathrsp-8}{8}\concat\mathtt{0xEEFF}.
  \end{equation*}
  Assuming an intial condition of $\mathrsp=\rspo$,
  the set~$M$ of memory regions required for the given block of assembly is ultimately
  \begin{equation*}
  M=\{\region{\rspo-8}2,\region{\rspo-4}4,\region{\rspo-7}2,
  \region{\rspo-6}4,\region{\rspo-8}8\}.
  \end{equation*}
\end{example}

\section{Rewrite Rules for Memory Usage}

\section{Summary}
This chapter introduced
