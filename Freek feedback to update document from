SAFECOMP/CFG chapter:

- Page 7, par 4 up to page 8, par 2: This paragraph should explain the methodology, but halfway it starts talking about limitations/complications. This is a nice example of what I meant with the adage “one paragraph, one message”. This paragraph should solely describe the methodology, so it should not delve into details of why recursive functions are difficult. Those can come later. Finally, I would highly recommend explaining every step using a tiny example, something without loops. Provide the 1.) assembly, provide 2.) the output of the angr script (i.e., the cut-points), provide 3.) the invariant, 4.) the regions and 5.) an insight into the proof required to finish the example. This is thus 5 separate paragraphs, each of them taking the reader by the hand. This can be highly similar to what we did in our POPL submission.
- The 6.3: "Strictly speaking, a transitive closure over Floyd invariant annotations would be required for a more formal proof.” Big big red flag. What do you mean? The current proof seems formal, what did I miss? BTW: I do not agree with the proof. You go from something of the form:

A /\ B —> C /\ D

to

C /\ (~B \/ D) /\ B —> C /\ D

Which is unsound.

- Section 6.4 somehow seems to overlap with the point made at the bottom of page 10. So I would restructure this. Also 6.4.2 is one paragraph. As a rule of thumb: whenever you have a subsection with one paragraph, think about the structure to eliminate this.
- I think the explanation of , e.g., the factorial function, can be much more elaborate. You dump the assembly without much explanation. I would show the CFG and explain for each basic block hat happens. Then take some more time to explain what the functions mulitplicands_pushed and ret_address do (easily one paragraph each). I would explain this before you refer the reader to Figure 6.3, so that wen he/she sees the figure, all terms have been explained.
- I would show a “theorem”, i.e., a Latex theorem environment, that shows the last three lines of section 6.5. That theorem should include the assumptions. That way, you actually have a theorem on memory preservation (because without assumptions, it seems like any address a is preserved). Similar for the pow2 example.
