%        File: VTthesis_template.tex
%     Created: Thu Mar 24 11:00 AM 2016 EDT
%     Last Change: Mon, April 30, 2018
%      Author: Alan M. Lattimer, VT
%	   With modifications by Carrie Cross, Robert Browder, and LianTze Lim.
%
% This template is designed to operate with XeLaTeX.
%
% All elements in the Title, Abstract, and Keywords MUST be formatted as text and NOT as math.

\documentclass[prelim]{VTthesis}

\usepackage{comment}               % for commenting out large amounts of stuff
\usepackage{suffix}                % For defining command versions with *s

\usepackage{stmaryrd}              % St Mary Road symbols for theoretical computer science (necessary for record/etc.\ symbols)
\usepackage{textcomp}              % Fixes issue with microtype+siunitx's \micro

\usepackage[en-US]{datetime2}      % For \DTMdate, etc.
\usepackage[binary-units]{siunitx}
\usepackage{mathtools}             % for \coloneqq
\usepackage{bussproofs}            % for prooftree environment
\usepackage[epsilon]{backnaur}     % For BNF diagrams; a (more complex?) alternative is the syntax package

\usepackage{booktabs}              % For nicer-looking tables
\usepackage{makecell}              % For table heading cells and cells with line breaks
\usepackage{threeparttable}        % For tables with notes

\usepackage[index,single,hyperref,display-foreign=false]{acro}                  % For acronyms; hyperref option doesn't work right with XeLaTeX and display-foreign=false used to avoid bug with plural initial forms

\usepackage{pgfplots}               % For plots

\usetikzlibrary{external}          % To reduce build times for complex figures (does one-time builds and stores as images)
\usetikzlibrary{graphs}            % dot-style graph shorthands (not quite as compactible as dot language, though)
\usetikzlibrary{quotes}            % needed for quoted edge labels (only in graphs?)
\usetikzlibrary{positioning}       % For relative (=of) node positioning

\renewcommand*\theadfont{} % not making table text small so no need for small heading

\acsetup{first-long-format=\emph, format-include-endings} % Can't seem to get the first-long-format to apply to a plural form

% Hack to fix ylabel positioning with current version of pgf
\makeatletter
\def\pgfsys@hboxsynced#1{%
  \pgfsys@beginscope\pgflowlevelsynccm\pgfsys@hbox#1\pgfsys@endscope%
}%
\makeatother

\pgfplotsset{compat=1.15}          % For up-to-date features
%\tikzexternalize[prefix=extern/]                  % Enables externalization (sometimes has issues with figures containing references, it seems, so turn off externalization when you need those)

\DeclareAcronym{abi}{
  short            = ABI,
  short-indefinite = an,
  long             = application binary interface,
  long-indefinite  = an
}
\DeclareAcronym{aec2}{short=Amazon EC2, long=Amazon Elastic Compute Cloud}
\DeclareAcronym{aes}{short=AES, long=Advanced Encryption Standard}
\DeclareAcronym{afp}{short=AFP, long=Archive of Formal Proofs, cite={afp}}
\DeclareAcronym{alu}{short=ALU, long=arithmetic logic unit}
\DeclareAcronym{api}{
  short            = API,
  short-indefinite = an,
  long             = application programming interface,
  long-indefinite  = an
}
\DeclareAcronym{aot}{
  short            = AOT,
  short-indefinite = an,
  long             = ahead-of-time,
  long-indefinite  = an
}
\DeclareAcronym{asl}{
  short            = ASL,
  short-indefinite = an,
  long             = ARM Specification Language,
  long-indefinite  = an,
  cite = {reid2016arm}
}
\DeclareAcronym{ast}{
  short            = AST,
  short-indefinite = an,
  long             = abstract syntax tree,
  long-indefinite  = an
}
\DeclareAcronym{atp}{
  short            = ATP,
  short-indefinite = an,
  long             = automated theorem prover,
  long-indefinite  = an
}
\DeclareAcronym{bap}{
  short = BAP,
  long = the Binary Analysis Platform,
  cite = {brumley2011bap}
}
\DeclareAcronym{bcd}{short=BCD, long=binary-coded decimal}
\DeclareAcronym{can}{short=CAN, long=Controller Area Network}
\DeclareAcronym{cfg}{short=CFG, long=control flow graph}
\DeclareAcronym{cfi}{short=CFI, long=control-flow integrity, cite={abadi2009cfi}}
\DeclareAcronym{ci}{short=CI, long=continuous integration}
\DeclareAcronym{csp}{short=CSP, long=communicating sequential processes}
\DeclareAcronym{cpu}{short=CPU, long=central processing unit}
\DeclareAcronym{dm}{short=DM, long=device model}
\DeclareAcronym{dil}{
  short = DiL,
  long = decompilation into logic,
  cite = {myreen2008decompilation,myreen2012decompilation}
}
\DeclareAcronym{dvr}{short=DVR, long=dead variable reduction}
\DeclareAcronym{elf}{short=ELF, long=Executable and Linkable Format}
 \DeclareAcronym{fdl}{
  short            = FDL,
  short-indefinite = an,
  long             = functional description language
}
\DeclareAcronym{fmuc}{
  short            = FMUC,
  short-indefinite = an,
  long             = formal memory usage certificate
}
\DeclareAcronym{fpu}{
  short            = FPU,
  short-indefinite = an,
  long             = floating-point unit
}
\DeclareAcronym{fsm}{
  short            = FSM,
  short-indefinite = an,
  long             = finite-state machine
}
\DeclareAcronym{hol}{
  short            = HOL,
  short-indefinite = an,
  long             = higher-order logic
}
\DeclareAcronym{hvm}{
  short            = HVM,
  short-indefinite = an,
  long             = hardware virtual machine
}
\DeclareAcronym{gcc}{short=GCC, long=the GNU Compiler Collection}
\DeclareAcronym{gcm}{short=GCM, long=Galois/Counter Mode}
\DeclareAcronym{gfp}{short=GFP, long=greatest fixed point}
\DeclareAcronym{gpu}{short=GPU, long=graphics processing unit}
\DeclareAcronym{icc}{
  short            = ICC,
  short-indefinite = an,
  long             = the Intel C++ Compiler
}
\DeclareAcronym{il}{
  short            = IL,
  short-indefinite = an,
  long             = intermediate language
}
\DeclareAcronym{iot}{
  short            = IoT,
  short-indefinite = an,
  long             = Internet of Things,
  long-indefinite  = an
}
\DeclareAcronym{ipc}{
  short            = IPC,
  short-indefinite = an,
  long             = inter-process communication,
  long-indefinite  = an
}
\DeclareAcronym{isa}{
  short            = ISA,
  short-indefinite = an,
  long             = instruction set architecture,
  long-indefinite  = an
}
\DeclareAcronym{isar}{
  short            = Isar,
  short-indefinite = an,
  long             = intelligible semi-automated reasoning
}
\DeclareAcronym{itp}{
  short            = ITP,
  short-indefinite = an,
  long             = interactive theorem proving,
  long-indefinite  = an
}
\DeclareAcronym{jit}{short=JIT, long=just-in-time}
\DeclareAcronym{jvm}{short=JVM, long=Java virtual machine}
\DeclareAcronym{lfp}{
  short            = LFP,
  short-indefinite = an,
  long             = least fixed point
}
\DeclareAcronym{mc}{short=MC, long=model checking}
\DeclareAcronym{mrr}{short=MRR, long=memory region relation}
\DeclareAcronym{msb}{short=MSB, long=most significant bit}
\DeclareAcronym{navsea}{short=NAVSEA, long=the Naval Sea Systems Command}
\DeclareAcronym{neec}{short=NEEC, long=the Naval Engineering Education Consortium}
\DeclareAcronym{nqthm}{
  short = Nqthm,
  long = the Boyer-Moore theorem prover,
  cite = {boyer1979computational}
}
\DeclareAcronym{os}{
  short            = OS,
  short-indefinite = an,
  long             = operating system,
  long-indefinite  = an,
  short-plural     = es
}
\DeclareAcronym{onr}{
  short            = ONR,
  short-indefinite = an,
  long             = the Office of Naval Research
}
\DeclareAcronym{psl}{short=PSL, long=Property Specification Language}
\DeclareAcronym{rop}{
  short            = ROP,
  short-indefinite = an,
  long             = return-oriented programming
}
\DeclareAcronym{qemu}{short=QEMU, long=Quick Emulator}
\DeclareAcronym{rtos}{
  short            = RTOS,
  short-indefinite = an,
  long             = real-time operating system
}
\DeclareAcronym{scc}{
  short            = SCC,
  short-indefinite = an,
  long             = strongly connected component
}
\DeclareAcronym{scf}{
  short            = SCF,
  short-indefinite = an,
  long             = syntactic control flow
}
\DeclareAcronym{simd}{short=SIMD, long={single instruction, multiple data}}
\DeclareAcronym{sloc}{short=SLOC, long=source lines of code}
\DeclareAcronym{smt}{
  short            = SMT,
  short-indefinite = an,
  long             = satisfiability modulo theories
}
\DeclareAcronym{spade}{
  short = SPADE,
  long = the Southampton Program Analysis Development Environment,
  cite = {carre1986spade}
}
\DeclareAcronym{sse}{
  short            = SSE,
  short-indefinite = an,
  long             = Streaming SIMD Extensions,
  long-indefinite  = an,
}
\DeclareAcronym{stp}{
  short            = STP,
  short-indefinite = an,
  long             = Simple Theorem Prover
}
\DeclareAcronym{tcb}{short=TCB, long=trusted computing base}
\DeclareAcronym{tv}{short=TV, long=translation validation}
\DeclareAcronym{vc}{short=VC, long=verification condition}
\DeclareAcronym{vcg}{short=VCG, long=verification condition generator}
\DeclareAcronym{vm}{short=VM, long=virtual machine}
\DeclareAcronym{vmm}{short=VMM, long=virtual machine monitor}
\DeclareAcronym{cisc}{short=CISC, long=complex instruction set computer}
\DeclareAcronym{risc}{short=RISC, long=reduced instruction set computer}

\lstdefinelanguage
  [x64]{Assembler}     % add an "x64" dialect of Assembler
  [x86masm]{Assembler} % based on the "x86masm" dialect
  % with these extra keywords:
  {morekeywords={CDQE,CQO,CMPSQ,CMPXCHG16B,JRCXZ,LODSQ,MOVSXD,% will add more insts as needed
    POPFQ,PUSHFQ,SCASQ,STOSQ,IRETQ,RDTSCP,SWAPGS,%
    MOVAPD,MOVDQA,%
    dil,eflags,rflags,cpuid,%
    rax,rdx,rcx,rbx,rsi,rdi,rsp,rbp,rip,%
    r8,r8d,r8w,r8b,r9,r9d,r9w,r9b,%
    r10,r10d,r10w,r10b,r11,r11d,r11w,r11b,%
    r12,r12d,r12w,r12b,r13,r13d,r13w,r13b,%
    r14,r14d,r14w,r14b,r15,r15d,r15w,r15b,%
    xmm0,xmm1,xmm2,xmm3,xmm4,xmm5,xmm6,xmm7,xmm8,xmm9,xmm10,xmm11,xmm12,xmm13,xmm14,xmm15%    
  }} % etc.
\lstdefinestyle{x64}{
  language=[x64]{Assembler},
  keywordstyle=\bfseries\color{blue}, % bold blue keywords
  commentstyle=\color{gray},
  stringstyle=\color{brown},
}
\lstdefinestyle{C}{
  language=C,
  keywordstyle=\bfseries\color{blue}, % bold blue keywords
  commentstyle=\color{gray},
  stringstyle=\color{brown},
}

%% name shorthands and stuff
\newcommand*\arch{x86-64}

\newcommand*\mcsquare{\textsc{[mc]square}}

\newcommand{\xenpercentage}{\SI{71}{\percent}}
\newcommand{\xenpercentagenot}{\SI{29}{\percent}}

\newcommand*\keywordstyle{\ttfamily\bfseries\color{blue}}
\newcommand\keyword[1]{{\keywordstyle#1}}
\newcommand*\inlineasm[1]{\lstinline[style=x64]|#1|}
\newcolumntype{A}{>{\begingroup\ttfamily\bfseries\color{blue}}l<{\endgroup}}

%% Math commands
\newcommand{\letin}[2]{\textbf{let} \(#1\) \textbf{such that} \(#2\)}
\newcommand{\ind}[1]{\hspace{#1}}
\newcommand*{\eqsetfix}{\mathrel{\phantom{=}}\phantom{\{}}
\newcommand*{\equivsetfix}{\mathrel{\phantom{\equiv}}\phantom{\{}}

\newcommand{\asp}{A_\mathrm{SP}}
\newcommand{\esp}{E_\mathrm{SP}}
\newcommand{\infloop}{\bot_\mathrm{NT}}
\newcommand{\err}{\bot_\mathrm{E}}
\newcommand{\bop}{\mathbin\bigcirc}
\newcommand{\nat}{\mathbb N}

\newcommand{\true}{\mathcal T}
\newcommand{\false}{\mathcal F}
\DeclareMathOperator{\powerset}{\mathcal P}

\DeclareMathOperator{\unat}{unat}
\DeclareMathOperator{\snd}{snd}
\newcommand{\concat}{\bullet}
\newcommand{\mmerge}{\text{ merge }}
\newcommand{\var}[1]{\mathit{#1}}

\DeclareMathOperator{\step}{\textsc{step}}
\DeclareMathOperator{\run}{\textsc{runUntil}}
\DeclareMathOperator{\loc}{loc}
\DeclareMathOperator{\rbxpops}{\textsc{multiplicandsPushed}}
\DeclareMathOperator{\retsites}{\textsc{retAddrsPushed}}
\DeclareMathOperator{\retaddress}{\textsc{retAddress}}
\DeclareMathOperator{\seps}{\bigotimes}

\DeclareMathOperator{\blockusage}{block_usage}
\DeclareMathOperator{\nbo}{\textsc{noBlockOverflow}}
\DeclareMathOperator{\sextend}{sextend}
\DeclareMathOperator{\usage}{preserve}
\DeclareMathOperator{\exec}{\textsc{execScf}}
\DeclareMathOperator{\execblock}{\textsc{symbExec}}

\newcommand*{\ASeq}{\mathrel{\texttt{;}}}
\WithSuffix{\newcommand*}\ASeq*{\texttt{;}}
\newcommand*{\AWhile}{\texttt{Loop}}
\newcommand*{\AOd}{\texttt{Pool}}
\newcommand*{\AIf}{\texttt{If}}
\newcommand*{\AThen}{\texttt{Then}}
\newcommand*{\AElse}{\texttt{Else}}
\newcommand*{\AFi}{\texttt{Fi}}
\newcommand*{\ABB}{\texttt{Block}}
\newcommand*{\ASkip}{\texttt{Skip}}
\newcommand*{\ACall}{\texttt{Call}}
\newcommand*{\ABreak}{\texttt{Break}}
\newcommand*{\AContinue}{\texttt{Continue}}
\newcommand*{\AWhileResume}{\texttt{Resume}}

\DeclareMathOperator{\scf}{scf}
\DeclareMathOperator{\pre}{pre}
\DeclareMathOperator{\post}{post}
\DeclareMathOperator{\ID}{ID}
\DeclareMathOperator{\exit}{exit}
\DeclareMathOperator{\sccs}{SCCS}
\DeclareMathOperator{\sem}{sem}
\DeclareMathOperator{\subst}{subst}

\DeclarePairedDelimiter{\takebits}{\langle}{\rangle}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}

\newcommand\Block[2]{\mathtt{#1\texttt{->}#2}}
\WithSuffix\newcommand\Block*[3]{#1~#2~#3}

\newcommand\region[2]{\ensuremath{[#1,#2]}}
\newcommand\readmem[2]{\ast\region{#1}{#2}}
\newcommand\readmemS[3]{#1:\readmem{#2}{#3}}
\newcommand\htriple[3]{\{#1\}#2\{#3\}}
\WithSuffix\newcommand\htriple*[4]{\{#1\}#2\{#3{;}#4\}}
\newcommand\parent[3]{\operatorname{parent}(#1,#2,#3)}
\newcommand\writeM{\stackrel{M}{=}}
\newcommand\writeR{\stackrel{R}{=}}
\newcommand\writeF{\stackrel{F}{=}}
\newcommand\writeone[3][\sigma]{#1\llparenthesis #2\writeM #3\rrparenthesis}
\newcommand\enclosed\sqsubseteq
\newcommand\separate\bowtie

\newcommand{\deqptr}{\var{deq}_\mathrm{ptr}}
\newcommand{\bufferptr}{\var{buf}_\mathrm{ptr}}
\newcommand{\outptr}{\var{out}_\mathrm{ptr}}
\newcommand{\valueptr}{\var{value}_\mathrm{ptr}}

\newcommand{\mathrax}{\text{\inlineasm{rax}}}
\newcommand{\mathrip}{\text{\inlineasm{rip}}}
\newcommand{\mathrbp}{\text{\inlineasm{rbp}}}
\newcommand{\mathrbx}{\text{\inlineasm{rbx}}}
\newcommand{\mathrdi}{\text{\inlineasm{rdi}}}
\newcommand{\mathrsi}{\text{\inlineasm{rsi}}}
\newcommand{\mathrsp}{\text{\inlineasm{rsp}}}
\newcommand{\mathdil}{\text{\inlineasm{dil}}}
\newcommand{\mathdl}{\text{\inlineasm{dl}}}
\newcommand{\mathfs}{\text{\inlineasm{fs}}}
\newcommand{\mathgs}{\text{\inlineasm{gs}}}
\newcommand{\mathGPR}{\mathtt{GPR}}

\newcommand{\fso}{\var{fs}_0}
\newcommand{\rdio}{\var{rdi}_0}
\newcommand{\rsio}{\var{rsi}_0}
\newcommand{\rspo}{\var{rsp}_0}
\newcommand{\rbpo}{\var{rbp}_0}

\newcommand{\retaddr}{\text{\lstinline|ret_addr|}}

\newcommand{\psep}{P_\mathrm{sep}}

% Misc. commands
\newcommand{\todo}[1]{{\bfseries\color{purple}#1}} % Allowing paragraphs in todos
\newcommand*{\fturl}[1]{\footnote{\url{#1}}}

\title{%
  Formal Verification of Memory Preservation for \arch\ Assembly via Proof Generation%
}
\keywords{%
  Formal Verification,
  \arch\ Assembly,
  Interactive Theorem Proving,
  Proof Generation,
  Memory Preservation%
}
\author{Joshua Alexander Bockenek}
\program{Computer Engineering}
\degree{Doctor of Philosophy}

\submitdate{\DTMdate{2019-09-02}}

\principaladvisor{Binoy Ravindran}
\firstreader{Freek Verbeek}
\secondreader{Patrick R. Schaumont}
\thirdreader{Michael S. Hsiao}
\fourthreader{Changhee Jung}

%\dedication{This is where you put your dedications.}
\acknowledge{%
  This work was supported in part by \ac{onr} under grant N00014-17-1-2297
  and \ac{navsea}/\ac{neec} under grant N00174-16-C-0018.
  Any opinions, findings, and conclusions or recommendations expressed
  in this dissertation are those of the author
  and do not necessarily reflect the views of \ac{onr} or \ac{navsea}/\ac{neec}.%
}

% The abstract is required and should be <=250 words for thesis, <=350 words for dissertation.
\abstract{%
  % Motivation
  Formal characterization of the memory used by a program is an important basis
  for security analyses and compositional verification. Proving that that program only modifies
  memory within specified regions, the property of \emph{memory preservation},
  is an important aspect of that. However, accurately proving memory preservation
  requires operating on the assembly level due to the semantic gap between
  high-level languages and the code that processors actually execute.
  This is unfortunate, as verifying programs on the assembly level is difficult.
  Automated methods, such as model checking, would not be able to handle many interesting functions
  due to the undecidability of memory preservation. Fully-interactive methods do not scale well either.
  The solution is to combine proof generation with interactive theorem proving
  in a \emph{semi-automated manner}: let some untrusted tool
  extract as much information as it can from the functions under test
  and then generate all the necessary proofs to be completed in a theorem prover.

  % First contribution
  The first contribution of this dissertation is a control-flow-driven verification
  approach with mostly manual invariant specification
  at automatically-selected cutpoints.
  The memory regions and any additional preconditions
  must also be determined manually.
  This methodology was applied to 63 functions from the HermitCore unikernel library,
  including one recursive one, covering \num{2379} assembly instructions.

  % Second contribution
  The second contribution of this dissertation is a syntax-driven verification
  approach with fully-automated invariant and memory region generation.
  It produces formal memory usage certificates that can be verified in Isabelle/HOL
  with minimal effort, the main manual work being weakening any loop invariants.
  This was successfully applied to 251 functions from the Xen hypervisor project,
  covering a total of \num{12252} assembly instructions.%
}

% TODO
% The general audience abstract is required. There are currently no word limits.
\abstractgenaud{%
  You are also required as of Spring 2016 to include a general audience abstract.
  This should be geared towards individuals outside of your field
  that may be reading seeking information about your work.
  You should avoid language that is particular to your field
  and clearly define any terms that may have special meaning in your discipline.%
}

\addbibresource{bibliography.bib}

\makeindex[intoc]
\begin{document}
  \frontmatter
  \maketitle

  \microtypesetup{protrusion=false} % suggested by the docs to avoid the list dots getting misaligned
  \tableofcontents
  \listoffigures
  \listoftables
  \listofalgorithms
  \lstlistoflistings
  \microtypesetup{protrusion=true}

  \printacronyms[heading=chapter]
  \printnomenclature

%  \input{attribution} % prefaces go in front matter | Binoy doesn't want it, but it'll be needed for the official version eventually

  \mainmatter
  \input{introduction}
  \input{related}
  \input{background}
  \input{symbolic_execution}
  \input{cfg}
  \input{syntax}
  \input{conclusions}

  {% appendices don't work right with backmatter on its own due to the lack of counters
    \backmatter
    \printbibliography[heading=bibintoc]
    \printindex
  }
%  \begin{appendices}
%    \renewcommand*\chaptername\appendixname % find a better spot
%  	\chapter{First Appendix} \label{app:appendix_one}
%  		\section{Section one} \label{ase:app_one_sect_1}
%      \clearpage
%  		\section{Section two} \label{ase:app_one_sect_2}
%  	\chapter{Second Appendix} \label{app:appendix_two}
%      \clearpage
%  		\section{Section a}
%  \end{appendices}
\end{document}
