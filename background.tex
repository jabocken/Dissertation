\chapter{Background}\label{ch:background}
This part of my dissertation provides domain-specific information necessary to understand
the work presented in it.
\todo{more intro}

It is grouped into the two main categories of
formal methods (\cref{se:formal_methods})
and assembly language (\cref{se:assembly_language}).
\todo{more on overview}

\section{Formal Methods}\label{se:formal_methods}
To quote \textcite{butler:fm},
\todo{should go in intro maybe}
\begin{quote}
  ``Formal Methods''%
  \index{formal!methods}
  refers to mathematically rigorous techniques and tools
  for the specification, design and verification of software and hardware systems.
\end{quote}
This dissertation comes under the \emph{verification} component of that,%
\index{formal!verification}

\subsection{Semantics}
Very often when working with formal tools, you must formulate formal semantics
for a language.

\Textcite{schmidt2003pls}

\subsubsection{Operational}
\paragraph{Big-Step}
\paragraph{Small-Step}

\subsubsection{Denotational}

\subsubsection{Axiomatic}
Axiomatic semantics provide meaning 
The canonical example is \emph{Hoare logic}.%
\index{Hoare!logic}

\subsection{Fixed Point Representation}
The \ac{lfp} and \ac{gfp} of a function are

\todo\dots

The \ac{lfp} of an infinite loop formulated in this way
is thus the bottom element $\infloop$.%
\nomenclature{$\infloop$}{Indicates non-terminating state}

\subsection{Symbolic Execution}
At its most basic, ``symbolic execution'' refers to
executing a program with a set of symbolic inputs
rather than concrete values \autocite{king1976symbolic}.
Based on the semantics of the program, the execution may end up taking multiple paths;
it could potentially be an infinite number if there are loops involved.

\todo{more}

\todo{The below doesn't really sound right.}
In this work, the individual steps of symbolic execution
are implemented as \emph{rewrite rules} over the state%
\index{symbolic execution!rewrite rule}
that derive their representation from 
Applying those rules in sequence to each step or instruction of a program
allows aggregation of the individual state changes involved in the execution.

\subsection{Floyd Flowcharts}\label{se:floyd}

\subsection{Hoare Logic}\label{se:hoare}
A form of \emph{axiomatic semantics},
\index{semantics!axiomatic}
Hoare logic \autocite{hoare1969axiomatic,myreen2007hoare}%
\index{Hoare!logic}
describes the behavior of a program
in terms of a set of rules that are applied iteratively
in order to syntactically decompose the program into its constituent behaviors.

A \emph{Hoare triple} denotes a pre- and postcondition for a certain program.%
\index{Hoare!triple}%
\index{precondition}%
\index{postcondition}
Let~$P$ and~$Q$ be state predicates.

\todo{more}

\subsubsection{Verification Condition Generation}
%TODO

There are two ways of performing verification condition generation%
\index{verification condition generation}:
either start at the end and go backwards, deriving the \emph{weakest precondition},%
\index{precondition!weakest}
or start at the front and go forwards, deriving the \emph{strongest postcondition}.%
\index{postcondition!strongest}
The weakest-precondition approach appears most common,
being the canonical methodology.\todo{need citation}

%TODO

\subsection{\acs*{smt} Solvers}
\Ac{smt} solvers are designed to solve the \acl{smt} decision problem.
That is, 

\subsection{Theorem Proving}
%
\index{theorem prover}

\subsubsection{Automated versus Interactive}
\index{theorem prover!interactive}

\subsubsection{Isabelle and HOL}
The theorem prover utilized in this work
was Isabelle 2018 \autocite{nipkow2002isabelle}.%
\index{Isabelle/HOL}
It is a generic proof assistant with a flexible, extensible syntactic framework.
Isabelle also utilizes a powerful proof language
known as \ac{isar}  \autocite{wenzel2007isabelle}
and a proof method language called Eisbach \autocite{matichuk2016eisbach}.
Its most-commonly-used logic is \ac{hol}; when used with that logic,
it is referred to as Isabelle/HOL.

\paragraph{HOL-Word}
We made heavy use of Isabelle/HOL's Word library \autocite{isabelle-word-session}
for the work presented in this dissertation.
That library provides a limited-precision integer type, \lstinline|'a word|,
where \lstinline|'a| is the number of bits in the integer.
Various operations are provided for manipulation of and arithmetic involving formal words,
including bit indexing, bit shifting, setting specific bits,
and signed and unsigned arithmetic.
Operators for inequality are also included,
as well as operations for converting between word sizes.

\paragraph{Eisbach}
\todo{explain basic steps, how +, ?, commas, etc. work and all}

%\todo{this is redundant with the info presented in symb exec}
%In order to perform symbolic execution of assembly instructions in Isabelle,
%the instructions must somehow be embedded in the theorem prover.
%This is done using the symbolic execution toolchain
%of \textcite{roessle2019},
%the \emph{machine model} of which is based on the work of \textcite{heule2016stratified}.%
%\index{symbolic execution!machine model}

%
\index{embedding!shallow}%
\index{embedding!deep}

\section{Assembly Language}\label{se:assembly_language}
No modern high-level programming language is ever executed directly on hardware.
Instead, they are \emph{compiled},%
\index{compilation}
either before execution (\ac{aot} compilation \autocite{})%
or at runtime (\ac{jit} compilation \autocite{}),
to low-level \emph{machine code}, specified by the \ac{isa} of the \ac{cpu} in use.
One step above machine code is assembly language,
which \todo\dots.

\subsection{The \arch\ Instruction Set Architecture}
\Iac{isa} is the specification of the visible behavior of a processor.
They have long been published as human-readable documents
\autocite{bowen1985cards,intel2019manual},
though ARM recently released several of their \acp{isa} in a machine-parsable,
executable format \autocite{reid2016arm}. While not directly verifiable,
such a format greatly aids in developing a model that is \autocite{reid2016endtoend}
(in the case of the cited paper, for a model checker.).




The general features specified include the supported data types,
what state there is (such as the main memory and registers)
and their semantics (such as the memory consistency and addressing modes), the instruction set (the set of machine instructions that comprises a computer's machine language), and the input/output model. \todo{rewrite, need citation from Wikipedia}

In the case of ARM's machine-parsable release, they separated out the register model
from the instruction as separate files.


Historically, there have been two main types of \acp{isa}:
\acp{cisc} and \acp{risc} \autocite{jamil1995rc}.
\Acp{cisc} came first, featuring complex \acp{isa} with multiple addressing modes
and many variable-length instructions with in-depth behavior.
\Acp{risc} were a response to the growing complexity of \ac{cisc} designs,
providing a set of simple instructions that,
other than loads and stores for memory access, only operate on a large register file.
The main push for \acp{risc} was actually a desire
to reduce the complexity of implementations. \Ac{risc} instructions being
generally simpler than their \ac{cisc} equivalents
means less circuitry is required to implement them,
which reduces die size/chip surface area and allows for increases in clock speed.
This also allows the instructions themselves to complete faster,
with most \ac{risc} instructions finishing in one clock cycle
compared to the many many-cycle instructions of \acp{cisc}.

Currently, \acp{risc} are used more often for systems that require
low-power operation while \acp{cisc} are used more for high-performance applications.
In modern times, however, differentiating between the two types of architectures
due to power or performance concerns is no longer as relevant as it used to be.
For current designs, the differences in performance and power
have more to do with implementation than \ac{isa} \autocite{blem2013struggles}.

In the end,
this dissertation used the \arch\ \ac{isa} as it is a widely-used architecture
that has had formal semantics derived for most of its instructions
in previous works \autocite{heule2016stratified,roessle2019}.
It is the 64-bit, mostly-backwards-compatible successor to the x86 \ac{isa},
also known as x64, x86\_64, AMD64 (for AMD chips), and Intel 64 (for Intel chips).
The x86 family of processors originated in 1978 with the 16-bit Intel 8086,
whose design is still reflected in that of modern x86 \acp{isa}.
Many of the instructions are the same,
though extended over the years to work with larger operands.
There are also many new instructions that have been added over the years.

The rest of this section describes features and properties of \arch\ that are relevant
to this dissertation.

\subsubsection{State}
\paragraph{Memory}
\todo\dots


% Size restrictions
Currently, though addresses in the \arch\ \ac{isa} are ostensibly 64 bits in length,
not all of those bits are available for addressing.
The physical address bus itself is only 48 bits
\todo\dots

While the \arch\ \ac{isa} could potentially use the full $2^{64}-1$
range of values for addressing, as addresses are 64~bits in size,
current implementation restrictions limit physical processors to
52~bits for their address bus and~48 for virtual memory.

\paragraph{Registers}
Registers in \arch\ \todo\dots
\begin{table*}
  \centering
  \renewcommand\theadfont{\normalcolor\normalsize\normalfont}
  \begin{threeparttable}
    \caption{The most commonly used \arch\ registers}\label{tbl:regs}
    \begin{tabular}{lAAAAA}
      \toprule
      \thead{Purpose} & \thead{\SI{64}\bit} & \thead{\SI{32}\bit} &
      \thead{\SI{16}\bit} & \thead{\SI{8}{\bit} high} & \thead{\SI{8}{\bit} low} \\
      \midrule
      General Purpose\tnote{a} & rax & eax & ax & ah & al \\
      General Purpose\tnote{b} & rbx & ebx & bx & bh & bl \\
      General Purpose\tnote{c} & rcx & ecx & cx & ch & cl \\
      General Purpose\tnote{d} & rdx & edx & dx & & dl \\
      General Purpose\tnote{e} & rsi & esi & si & & sil \\
      General Purpose\tnote{f} & rdi & edi & di & & dil \\
      Base Pointer & rbp & ebp & bp & & spl \\
      Stack Pointer & rsp & esp & sp & & bpl \\
      Program Counter/Inst.\ Pointer & rip & eip & ip \\
      Processor Status & rflags & eflags & flags \\
      \bottomrule
    \end{tabular}
    \begin{tablenotes}
      \item[a] Formerly the primary accumulator (temporary variable)%
        \index{accumulator!primary}
      \item[b] Formerly base%
        \index{accumulator!base}
      \item[c] Formerly counter%
        \index{accumulator!counter}
      \item[d] Formerly data%
        \index{accumulator!data}
      \item[e] Formerly source index for string operations
      \item[f] Formerly destination index for string operations
    \end{tablenotes}
  \end{threeparttable}
\end{table*}

\subsubsection{Instructions}
\todo\dots

\paragraph{Function Builders}

\paragraph{Control Flow}

\paragraph{\ac{simd}}
These instructions, which operate on multiple 64-bit chunks,
\todo\dots

\subsection{The System~V \acs*{abi}}
While \iac{isa} specifies the features of a processor and what they do,
it says nothing about how to use it.



The \ac{abi} this 
Originating from UNIX System~V, the System~V \ac{abi}
is an actively-maintained and widely used on many Unix-based systems,
including Linux distributions \autocite{systemv-ABI-git}.
The version used in this dissertation was for \arch.

\subsection{Basic Blocks}
Much of the memory work in this document relates to the concept of \emph{basic blocks}.%
\index{basic block}
A basic block is defined here as a sequence of assembly instructions
whose behavior can be described using only state transitions and branches.
A block always terminates and has no internal loops.
This definition differs slightly from the definition used by compilers such as LLVM,
in which basic blocks have the additional restriction that
each block must terminate with a control flow instruction
(or fall through, on the assembly level) and contain no other control flow instructions
\autocite{llvm:functions,llvm:terminators}.

\todo\dots

\subsection{Tail Call Optimization}
Tail call%
\index{recursion!tail call}
optimization, implemented in most major C and C++ compilers, is a technique
for converting recursive functions into loop-based ones that only use
a set number of stack frames.
Unfortunately, that can only be applied to functions that fit the requirements
for proper tail calls \autocite{probst2001proper},
as imperative languages like C were not designed with such features in mind.

\todo{little more? I reference it later in the dissertation}

\section{Summary}
