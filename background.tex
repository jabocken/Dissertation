\chapter{Background}\label{ch:background}
This part of my dissertation provides domain-specific information necessary to understand
the work presented in it.

\section{Formal Methods}
To quote \citet{butler:fm},
\todo{should go in intro maybe}
\begin{quote}
  ``Formal Methods''%
  \index{formal!methods}
  refers to mathematically rigorous techniques and tools
  for the specification, design and verification of software and hardware systems.
\end{quote}
This dissertation on the \emph{verification} component of that,%
\index{formal!verification}
which 

\subsection{Fixed Point Representation}
s

\subsection{Hoare Logic}\label{se:hoare}
A form of \emph{axiomatic semantics},
\index{semantics!axiomatic}
Hoare logic~\citep{hoare1969axiomatic,myreen2007hoare}%
\index{Hoare!logic}
describes the behavior of a program
in terms of a set of rules that are applied iteratively
in order to syntactically decompose the program into its constituent behaviors.

A \emph{Hoare triple} denotes a pre- and postcondition for a certain program.%
\index{Hoare!triple}%
\index{precondition}%
\index{postcondition}
Let~$P$ and~$Q$ be state predicates.

\todo{more}

\subsubsection{Verification Condition Generation}
%TODO

There are two ways of performing verification condition generation%
\index{verification condition generation}:
either start at the end and go backwards, deriving the \emph{weakest precondition},%
\index{precondition!weakest}
or start at the front and go forwards, deriving the \emph{strongest postcondition}.%
\index{postcondition!strongest}
The weakest-precondition approach appears most common,
being the canonical methodology.\todo{need citation}

%TODO

\subsection{Theorem Proving}
%
\index{theorem prover}

\subsubsection{Automated versus Interactive}
\index{theorem prover!interactive}

\subsubsection{Isabelle and HOL}
The theorem prover utilized in this work
was Isabelle 2018\fturl{https://isabelle.in.tum.de/}~\citep{nipkow2002isabelle}.%
\index{Isabelle/HOL}
It is a generic tool with a flexible, extensible syntactic framework.
Isabelle also utilizes a powerful proof language
known as \ac{isar}~\citep{wenzel2007isabelle}
and a proof method language called Eisbach~\citep{matichuk2016eisbach}.
We made heavy use of Isabelle's Word library~\citep{isabelle-word-session}
for the work presented in this dissertation.
That library provides a limited-precision integer type, \lstinline|'a word|,
where \lstinline|'a| is the number of bits in the integer.
Various operations are provided for manipulation of and arithmetic involving formal words,
including bit indexing, bit shifting, setting specific bits,
and signed and unsigned arithmetic.
Operators for inequality are also included,
as well as operations for converting between word sizes.

\paragraph{Eisbach}
\todo{explain basic steps, how +, ?, commas, etc. work and all}

%\todo{this is redundant with the info presented in symb exec}
%In order to perform symbolic execution of assembly instructions in Isabelle,
%the instructions must somehow be embedded in the theorem prover.
%This is done using the symbolic execution toolchain
%of \citet{roessle2019},
%the \emph{machine model} of which is based on the work of \citet{heule2016}.%
%\index{symbolic execution!machine model}

%
\index{embedding!shallow}%
\index{embedding!deep}

\section{Assembly Language}
\todo\dots

The x86-64
\index{x86-64}
\ac{isa}, originally 

\subsection{Basic Blocks}
Much of the memory work in this document relates to the concept of \emph{basic blocks}.%
\index{basic block}
A basic block is defined here as a sequence of assembly instructions
whose behavior can be described using only state transitions and branches.
A block always terminates and has no internal loops.
This definition differs slightly from the definition used by compilers such as LLVM,
in which basic blocks have the additional restriction that
each block must terminate with a control flow instruction and contain no other
control flow instructions.

\section{Summary}
