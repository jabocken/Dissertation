\chapter{Memory Usage}

Reading a region of memory from some state~$\sigma$
uses notation $\readmemS{\sigma}{a}{s}$.
In Isabelle, this operation internally reads the list of~$s$ bytes
starting from the given address~$a$ in the appropriate order and converts it to a word.
If it is clear from context which state is meant, the state will be omitted.
Meanwhile, writing to memory uses the notation $x\coloneqq e$,
which has type~$\asp=(\var{SP},\esp)$;
these \emph{assignments} denote writing an expression~$e$ to some location~$x$
that is a \emph{state part},~$\var{SP}$;%
\nomenclature{$\var{SP}$}{Type of state parts (regions, flags, and registers)}%
\index{state part}
it can be a region, register, or flag.
Flags can only take boolean expressions while
the result for a register must be a 64-bit word.
The behavior for regions in Isabelle is to internally decompose the expression to write
into its component bytes and then write those into memory in the appropriate order.
The expressions themselves are of type~$\esp$,%
\nomenclature{$\esp$}{Type of expressions}
representing expressions over state parts.
These expressions consist of common bit-vector operations including
taking subsets of bits, bitstring concatenation, logical operators, casting,
and floating-point, signed, and unsigned arithmetic.

Modifications to state are represented as sets of assignments,~$\powerset(\asp)$,
formulated as $A=\{x_0\coloneqq e_0,x_1\coloneqq e_1,\dotsc\}$.
These assignments are all independent; their initial conditions
are based off of whatever state is present before application of the assignments,
and thus they can be applied in any order.
As a simple example, consider the 









\todo\dots

To show the correctness of \cref{mem_pres_hoare},
the concept of memory usage with respect to state changes must first be defined.
\begin{definition}
  The set of memory regions~$M$ represents memory \emph{usage} with respect to
  the state change from starting state~$\sigma$ to halting state~$\sigma'$
  if and only if every byte outside of the prespecified regions in memory is unchanged.
  Those bytes are associated with the variable~$a$.
  \begin{equation}
    \usage(M,\sigma,\sigma')\equiv\forall a\cdot(\forall r\in M\cdot\region{a}1\separate r)
    \longrightarrow\readmemS{\sigma'}a{1}=\readmemS{\sigma}a{1}.
  \end{equation}
\end{definition}
\begin{example}
  \todo{This should actually come before the Hoare triple,
    along with the stuff that leads up to it, to better explain things}
\end{example}

\todo\dots

\section{Limitations}\label{mem_use_limits}
\todo\dots

\subsection{Overapproximation}\label{mem_use_over}
As a formal property, memory usage has been proven to never miss any memory regions
written to, assuming the correctness of the semantics and model it is applied
to~\citep{bockenek2019preservation,popl2019underreview}.
Put another way, however, this means that the methodology \emph{must} be conservative.
If it cannot make a determination about the usage status of some part of memory,
either due to an underdeveloped state or too large of one to easily reason about,
it must assume that that region is used. It must \emph{overapproximate}.%
\index{overapproximation}
This sort of false positive can be an issue in the field of formal verification,
as it can make the property under consideration weaker despite being correct.

One way to shrink such overapproximations is to increase the
\emph{context sensitivity}\index{context sensitivity}
of the approach, such as performing the analysis over the full program at once
rather than individual components, but that can involve
a significant increase in time and verification effort.

\todo{Want talk about the usage of SMT solvers/etc., increase in automation in general
  as one way of mitigating increased verification effort somewhere}

\section{Summary}
