\chapter{Memory Usage}











\todo\dots

To show the correctness of \cref{mem_pres_hoare},
the concept of memory usage with respect to state changes must first be defined.
\begin{definition}
  The set of memory regions~$M$ represents memory \emph{usage} with respect to
  the state change from starting state~$\sigma$ to halting state~$\sigma'$
  if and only if every byte outside of the prespecified regions in memory is unchanged.
  Those bytes are associated with the variable~$a$.
  \begin{equation}
    \usage(M,\sigma,\sigma')\equiv\forall a\cdot(\forall r\in M\cdot\region{a}1\separate r)
    \longrightarrow\readmemS{\sigma'}a{1}=\readmemS{\sigma}a{1}.
  \end{equation}
\end{definition}
\begin{example}
  \todo{This should actually come before the Hoare triple,
    along with the stuff that leads up to it, to better explain things}
\end{example}

\todo\dots

\section{Limitations}\label{mem_use_limits}
\todo\dots

\subsection{Overapproximation}\label{mem_use_over}
As a formal property, memory usage has been proven to never miss any memory regions
written to, assuming the correctness of the semantics and model it is applied
to~\citep{bockenek2019preservation,popl2019underreview}.
Put another way, however, this means that the methodology \emph{must} be conservative.
If it cannot make a determination about the usage status of some part of memory,
either due to an underdeveloped state or too large of one to easily reason about,
it must assume that that region is used. It must \emph{overapproximate}.%
\index{overapproximation}
This sort of false positive can be an issue in the field of formal verification,
as it can make the property under consideration weaker despite being correct.

One way to shrink such overapproximations is to increase the
\emph{context sensitivity}\index{context sensitivity}
of the approach, such as performing the analysis over the full program at once
rather than individual components, but that can involve
a significant increase in time and verification effort.

\todo{Want talk about the usage of SMT solvers/etc., increase in automation in general
  as one way of mitigating increased verification effort somewhere}

\section{Summary}
