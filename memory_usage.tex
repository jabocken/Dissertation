\chapter{Memory Usage}\label{ch:memory}

Something something \emph{memory usage}.
\index{memory!usage|textit}

\section{Definitions}
Much of the memory work in this document relates to the concept of \emph{basic blocks}.
\index{basic block}
A basic block is defined here as a sequence of assembly instructions
whose behavior can be described using only state transitions and branches.
A block always terminates and has no loops.
This definition differs slightly from the definition used by compilers such as LLVM,
in which basic blocks also do not contain any internal branching.

\subsection{Memory Regions}\label{sse:memory_regions}
\index{memory!region}

\section{Memory Region Relations}
\index{memory!region relation}

\section{Memory Preservation}\label{se:memory_preservation}
As an extension of memory usage,
memory preservation shows that the values written by a program
\index{memory!preservation}
are restrained to specified regions in memory.
Those regions cannot be fully identified when working with source code alone,
particularly when the end result is optimized.
Memory may be laid out differently depending on the \ac{isa} and \ac{abi} targeted,
as well as on the compiler used.
This can include positioning of global variables as well as the layout of stack frames.
\index{stack!frame}
While one way of resolving that issue would be to choose a specific compiler
and provide a formal analysis of how it arranges memory, that method is not flexible.
It may instead be better to target assembly or machine code directly,
as done in this dissertation.

\subsection{Usefulness}
The following small sections elaborate on the usefulness of memory preservation
as a platform for further verification efforts.

\subsubsection{Security}
Unbounded memory usage can lead to vulnerabilities
such as buffer overflows and data leakage.
One example of such a vulnerability would be 2014's Heartbleed~\citep{heartbleed}.
Heartbleed was caused by a lack of bounds checking on a string array
requested as output as part of a ``heartbeat'' message.
This, combined with a custom memory manager
that also had no security protections against out-of-bounds memory accesses,
lead to potential leakage of sensitive data such as passwords and encryption keys.
% TODO: need another, better example that involves data modification too
Memory preservation can serve as a foundation for formal security analyses
\index{memory!preservation}
that could be used to expose vulnerabilities involving malicious writes.

\subsubsection{Composition}
Scalability in verification is only feasible with composition.
Proofs of functional correctness over a large suite of software
require decomposing that suite into manageable chunks.
Separation logic provides a \emph{frame rule} that supports such decomposition\cite{reynolds2002separation}.
In words, the frame rule states that,
if a program or program fragment can be confined to a certain part of a state,
properties of that program or program fragment carry over
when used as part of a larger system involving that state.
Memory preservation allows for discharging the most involved part of the frame rule,
at least in terms of individual assembly functions.
That is, it shows that the memory usage of those functions is constrained
to specific regions in memory.
This can then serve as a basis
for any larger proof effort over multifunction assembly programs.

\subsubsection{Concurrency}
Reasoning over concurrent programs is complicated
due to the potential interactions between threads.
While there are ways of handling such interactions in a structured manner
via kernel- or library-provided \ac{ipc},
one method commonly used for the sake of efficiency is \emph{shared memory}.
Shared memory, in the context of this work,
refers to threads or processes sharing either a full memory space
or portions of one (via memory mapping)
that can be written to and read from freely by any thread or process with access to it.
Usage of shared memory can result in \emph{unintended} interactions between threads.
Memory preservation could be adapted to show the absence of such interactions
by proving that multiple threads only write
to specifically-allowed regions of shared memory.
Doing so would, of course, require a proper model of concurrency,
which is out of scope of this dissertation.

\subsection{Formal Definition}
The formal definition of memory preservation takes the form of a Hoare triple.
\index{memory!preservation}
\index{Hoare!triple}
Assume some predicate~$P$ that characterizes the initial state, at a minimum
by setting the instruction pointer to the first instruction of a function body.
Moreover, let~$R$ be the set of regions that the function is allowed to write to.
Set~$R$ includes the stack frame and utilized data sections from the source binary
as well as any utilized heap memory.
Memory preservation formulates that any byte not within any region in~$R$ has to remain unchanged throughout the execution of that function.
This is formalized as follows.
\begin{definition}
  Let~$R$ be a set of regions, let~$P$ be a precondition and let~$H$ denote a halting condition.
  A piece of assembly provides \emph{memory preservation} if and only if, for any address~$a$ and byte value~$v_0$:
  \begin{equation}
  (\forall r\in R\cdot r\bowtie\region{a}{1})\longrightarrow\htriple{P\wedge \readmem{a}{1}=v_0}{H}{\readmem{a}{1}=v_0}
  \end{equation}
\end{definition}


\todo\dots
% TODO: move to a proper location

First, we define the notion of memory usage with respect to a certain state change:
\begin{definition}
  The set of memory regions~$M$ represents \emph{memory usage} with respect to
  the state change from $\sigma$ to $\sigma'$ if and only if
  any byte at an address~$a$ not inside one of the regions is unchanged.
  \begin{equation}
    \usage(M,\sigma,\sigma')\equiv\forall a\cdot(\forall r\in M\cdot\region{a}{1}\bowtie r)
    \longrightarrow\readmemS{\sigma'}{a}{1}=\readmemS{\sigma}{a}{1}.
  \end{equation}
\end{definition}
