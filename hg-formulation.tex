\chapter{Technical Formulation}
\todo{copy the stuff over here}

\nomenclature[operator]{$\holds$}{Indicates that the state predicate or memory model on the \ac{rhs} holds for the state on the \ac{lhs}}

\section{Predicates}
\emph{Predicates}\index{state!predicate} are assertions on state.
A predicate~$P$\nomenclature{$P$}{A state predicate}
consists of a set of \emph{clauses}\index{state!predicate!clause}.
$P$ holds in state~$s$%
\nomenclature{$s$}{A concrete state \todo{give better clarification for this elative to the Hoare Graphs; gets introduced earlier though so maybe not?}}
($s\holds P$) if and only if all clauses hold.

\todo{maybe put more here? Connect to logical predicates}

Breaking it down further, a clause consists of two symbolic expressions\index{symbolic!expression}
and their relation.
A symbolic expression of type \gls{expression} consists of the some combination of the following:
\begin{itemize}
  \item register references (\gls{register}),
  \item flag references (\gls{flag}),
  \item 64-bit words (\gls{word}),
  \item symbolic values (\gls{val}),
  \item memory regions (modeled by an expression for the address and a natural number\index{number!natural} for the size)%TODO: \gls!
  \index{memory!region}, and
  \item the application of an operator\index{symbolic!operator}
  to a list of expressions.
\end{itemize}
In formal notation, this is:
\begin{equation}
  \gls{expression}\coloneqq
  \gls{register}\mid
  \gls{flag}\mid
  \gls{word}\mid
  \gls{val}\mid
  \gls{expression}\times\gls{nat}\mid
  \mathsf{Op}\times[\gls{expression}]
\end{equation}
\nomenclature[operator]{$\coloneqq$}{Indicates that the \ac{rhs} defines the \ac{lhs} for \ac{hg} and \ac{eicfg} work}%
We identify a subset of these symbolic expressions called \emph{constant expressions} (\gls{constant}).
These expressions cannot contain state parts\index{state!part}
such as registers, flags, or memory regions.%
\index{symbolic!register}%
\index{symbolic!flag}%
\index{memory!region}
They represent constants or computations constructed using initial values.%
\index{initial!value}
For example, $\rdio$ denotes the initial symbolic value%
\index{symbolic!value}%
of register~$\reg{rdi}$.
% TODO: This should probably be nomenclature somehow but I'm not sure how
This value does not change during symbolic execution\index{symbolic!execution}.

In notation, clauses\index{state!predicate!clause}
take the form $\gls{expression} \mathbin{\square} \gls{constant}$,%
\nomenclature[operator]{$\square$}{A placeholder for some binary relation}%
\nomenclature[operator]{$\in$}{Indicates that the \ac{lhs} is an element of the set on the \ac{rhs}}
where $\square\in\{=,\neq,<,<_s,\ge,\ge_s\}$.
The~$\square_s$ relations treat their operands as signed,
while the corresponding non-subscripted versions treat their operands as unsigned.

There are also two special clauseless predicates,~$\top$%
\nomenclature{$\top$}{Top; an always-true symbolic state predicate}
and~$\bot$.
Those special predicates respectively indicate always true (holds for any state) and always false (holds for no state).
$\bot$ is also used to indicate an unknown~\gls{constant}.%
\nomenclature{$\bot$}{Bottom; an always-false symbolic state predicate or an unknown/undefined~\gls{constant}
  \todo{make sure this does not conflict with any other definitions}}
\begin{definition}\label{def:join}
  The aforementioned join\index{lattice!join}
  of two predicates~$P$ and~$Q$,%
  \index{state!predicate}
  notation $P\join Q$,\nomenclature[operator]{$\join$}{The join of two state predicates\index{state!predicate}}
  is performed by doing a form of range abstraction for symbolic bit-vector values \autocite{rugina2000symbolic}.\index{symbolic!bit vector}
  This is defined as:
  \begin{align*} % \defeq doesn't seem right here since we already have \equiv (nomenclatured elsewhere); also don't we have \coloneqq already anyway?
    P\join Q &\equiv \bigcup\{\merge(p,q) \mid \langle p,q\rangle\in P\times Q\} \\
    \merge(l=r_1,l=r_2) &\equiv \{l\ge\min(r_1,r_2),l\le\max(r_1,r_2)\} \\
    \merge(l<r_1,l<r_2) &\equiv \{l<\max(r_1,r_2)\} \\
    &\vdots\\
    \merge(a,b) &\equiv
    \begin{cases}
      \{a\} & \text{if }a=b \\
      \varnothing & \text{otherwise}
    \end{cases}
  \end{align*}
\end{definition}
The operator presented in \cref{def:join}
performs a \emph{merge} for each clause pair\index{state!predicate!clause}
$\langle p,q\rangle$
in the Cartesian product\index{Cartesian product} % change to Cartesian!product if you use more references to Cartesian stuff
of its argument predicates.
This merge produces a potentially empty set of clauses
generated from the two clauses supplied to it.
% The union of all sets produced is then taken, resulting in the joined predicate.
While only merge rules for $=$ and $<$ are shown, there are also rules
for the other possible clause operations.
The~$\max$ and~$\min$ functions used are partial;%
\index{function!maximum}%
\index{function!minimum}%
\index{function!partial}
they do not have a result if the maximum/minimum of the expressions supplied to them cannot be determined.%
\index{maximum}
\index{minimum}
This can happen if those symbolic expressions\index{symbolic!expression}
contain unrestricted values\index{symbolic!value}.
In such cases, no clause is produced.
%The supremum, repeated join over a set of predicates, is denoted by $\bigsqcup\square$. % do we even have a supremum here anymore?

\begin{example}
  Let $P=\{a=3,a<\rdio\}$ and $Q=\{a=4,a<\rsio\}$.
  As both predicates\index{state!predicate}
  have equality clauses\index{state!predicate!clause}
  for~$a$, those clauses are merged to produce a pair of clauses denoting that the value of~$a$ lies in the range $[3,4]$.
  Since no maximum can be established between $\rdio$ and $\rsio$, these clauses are dropped.
  Thus, $P\join Q=\{a\ge 3,a\le4\}$.
\end{example}

As required for a lattice,\index{lattice}
the join\index{lattice!join}
is associative,\index{associative}
commutative,\index{commutative}
and idempotent.\index{idempotent}
Associativity is derived from the fact that set union\index{set!union}
and minimum/maximum%
\index{minimum}%
\index{maximum}
are associative operations.
The join is commutative and idempotent due to the commutativity and idempotency of the merge function. Finally, we have the following for any state~$s$\index{state}:
\begin{lemma}\label{lem:pred_soundness}
  $s\gls{holds}P\vee Q\implies s\gls{holds}P\gls{join}Q$
\end{lemma}
\begin{proof}
  The proof of this lemma consists of two cases:
  \begin{align*}
    s\gls{holds}P &\implies s\gls{holds}P\gls{join}Q \\
    s\gls{holds}Q &\implies s\gls{holds}P\gls{join}Q
  \end{align*}
  Only one of those cases needs to be proven;
  the other follows from the symmetry of the join\index{lattice!join} operation.
  Assuming~$s\gls{holds}P$, we now show $s\gls{holds}P\gls{join}Q$.
  For $s\gls{holds}P\gls{join}Q$ to be true, all of its clauses%
  \index{state!predicate!clause}
  must hold.
  Let~$c$ be one of the clauses resulting from the join.
  It is the result of one of the merge rules.
  Consider the first case, for equality.
  Since $l=r_1$ is a clause in~$P$, we have $l\ge\min(r_1,r_2)$ and $l\le\max(r_1,r_2)$.
  The other cases are similar.

  \todo{double-check this}
\end{proof}

\section{Memory Models}\label{sec:memory-models}
Program analysis\index{program!analysis}
in programs with pointers\index{pointer}
requires efficient alias identification and classification.
When different variables\index{variable}
(or in our case, state parts)\index{state!part}
point to the same memory region, those variables are \emph{aliased}.\index{memory!aliasing}
This is an important issue that must be dealt with for proper predicate transformation.
That is because alias information directs assignments to memory\index{memory!write}.
Specifically, when two state parts are aliased,%
\footnote{Or rather, the symbolic expressions\index{symbolic!expression}
  recorded as being stored in them alias.}
writing to the symbolic location (memory region) specified by one of them will change the value that is read from the symbolic location (memory region) specified by the other.
Unfortunately, it is not always possible to determine whether or not
two state parts alias.

We thus keep track of memory regions read and written during a sequence of execution in structured \emph{memory models}.%
\index{memory!read}%
\index{memory!model}
These memory models store \emph{aliasing}, \emph{separation},%
\index{memory!separation}
and \emph{enclosure}\index{memory!enclosure}
relations for memory regions.\index{memory!region}
This allows for efficient checks of those relations.
Furthermore, constructing them in a nondeterministic\index{nondeterminism}
fashion allows for dealing with multiple potential combinations of relations
between read and written regions in memory.
They are defined by the following data structures:
\begin{align*}
  \gls{memtree} &\coloneqq
  \{\gls{constant}\times\gls{nat}\}\times\gls{mem}
  &
  \gls{mem} &\coloneqq \{\gls{memtree}\}
\end{align*}
That is,
a memory model consists of a possibly empty \emph{forest} of memory trees.%
\index{memory!tree}%
\index{memory!forest}
Each memory tree has as a top-level node,\index{memory!node}
a set of memory regions,\index{memory!region}
and a possibly empty sub-forest that holds its child regions.
Two regions in the same node set alias.
The child regions are enclosed in their parents.
Finally, regions in sibling nodes are separate.

\begin{example}
  Consider the two memory models presented in \cref{fig:mem}.
  These memory models involve three regions: $\region{\rdio}{8}$,
  $\region{\rsio}{8}$ and $\region{\rsio+4}{4}$.
  The memory models depict the case where $\rdio$ and $\rsio$ alias and not alias.
  As stated above, sibling nodes on the same level are separate, while children are enclosed by their parents.
  Regions within the same node alias.
  Thus, \cref{fig:memA} shows a situation with
  two top-level regions aliasing and the child region they share.
  \Cref{fig:memB}, meanwhile, shows a situation where the two top-level regions do not alias,
  and thus only one of those regions contains an enclosed child.
\end{example}
\begin{figure}
  \hspace*\fill
  \subcaptionbox{Aliasing\label{fig:memA}}{
    \begin{tikzpicture}[every node/.style=draw]
      \node (a) {$\{\region{\rdio}{8},\region{\rsio}{8}\}$};
      \node[below=of a] (b) {$\region{\rsio+4}{4}$};

      \draw[->] (a) -- node [draw=none,midway, left, fill=white] {\rotatebox{90}{\gls{enclosed}}}(b); % keeping spacing aligned
    \end{tikzpicture}%
  }
  \hfill
  \subcaptionbox{No aliasing\label{fig:memB}}{%
    \begin{tikzpicture}[every node/.style=draw]
      \node (a) {$\region{\rdio}{8}$};
      \node[right=of a] (b) {$\region{\rsio}{8}$};
      \node[below=of b] (c) {$\region{\rsio+4}{4}$};

      \draw (a) -- node [draw=none,midway, above, fill=white] {\gls{separate}} (b) ;
      \draw[->] (b) -- node [draw=none,midway, left, fill=white] {\rotatebox{90}{\gls{enclosed}}} (c);
    \end{tikzpicture}%
  }
  \hspace*\fill
  \caption{Memory model examples}
  \label{fig:mem}
\end{figure}

\begin{definition}\label{def:memory-relations}
  Let~$s$ be a concrete state and let $r_0=\region{e_0}{n_0}$ and $r_1=\region{e_1}{n_1}$ be two regions in memory.
  Then, the properties of \emph{aliasing}, \emph{separation}, and \emph{enclosure}, notations \gls{alias}, \gls{separate}, and \gls{enclosed}, respectively, are defined as:
  \begin{align*}
    r_0\gls{alias}r_1 &\gls{defeq}s \gls{holds} e_0 = e_1 \wedge n_0 = n_1 \\
    r_0\gls{separate}r_1 &\gls{defeq}s \gls{holds} (e_0 + n_0 \le e_1) \vee (e_1 + n_1 \le e_0)\\
    r_0\gls{enclosed}r_1 &\gls{defeq}s \gls{holds} e_0 \ge e_1 \wedge e_0 + n_0 \le e_1 + n_1
  \end{align*}
\end{definition}
Such relations hold \emph{necessarily} if and only if they hold in all concrete states~$s$.
For example, $\region{\rsio}{4}\gls{separate}\region{\rsio+4}{4}$ is a necessarily-separate relation as there are no values of~$\rsio$ for which those two regions are not separate.
The \ac{smt} solver/theorem prover Z3 \autocite{de2008z3} is used to establish whether these ``necessarily''-relations hold for symbolic addresses\index{symbolic!address}
given the current state predicate\index{state!predicate}.
This is done via expression translation directly to Z3's bit-vector\index{numeric!bit vector}
representations, meaning no information is lost in the conversion
and when querying the constructed logical formulas.

In our Z3 interface, each operation to determine aliasing/separation/enclosure
also takes a predicate as an additional argument.
This is used to provide additional assumptions for necessarily-calculations,
as in isolation it is often not possible to determine the relationships between
entirely symbolic expressions\index{symbolic!expression}
that do not share symbolic values.\index{symbolic!value}
While the predicate may not help in all cases,
there may be instances where a relation between two symbolic values
or expressions was expressed previously in the program.

We further extend the notation in \cref{def:memory-relations} to memory trees.
That is, $t_0\gls{separate}t_1$ denotes that all regions in~$t_0$ are necessarily separate from all regions in~$t_1$.
Notation $t_0\gls{alias}t_1$ ($t_0\gls{enclosed}t_1$) denotes that some region in the top node of~$t_0$ and some region in the top node of~$t_1$ necessarily alias (are enclosed).
%Similarly,  denotes that some region in the top node of~$t_0$ is necessarily enclosed in some region of the top node of~$t_1$.

\subsection{Insertion}
Construction of a memory model is performed
using the recursive $\mathit{ins}$ function shown below.
It takes as input a memory tree~$t$ and the current memory model~$M$.
The current predicate~$P$ is also supplied
to assist in the region relationship analysis.
However, it is elided from the below presentation as it is a read-only value
that is passed along through the function call chain.
For output, function $\mathit{ins}$ produces, nondeterministically,
a set of new memory models based on all possible pointer relationships
for the newly-inserted region.
If no necessarily-relation can be established between~$t$ and any tree in~$M$, then all trees possibly overlapping with~$t$ are destroyed (see \cref{sec:intro}).
If a necessarily-relation can be established between tree~$t$ and some tree already in~$M$, then only the relevant memory models need to be produced.

To ensure that the invariants for the memory model~$M$ being inserted into
are not violated, the external interface to the function takes a single region,~$r$, instead of a memory tree.
This region is embedded in a minimal memory tree,
$\langle \{r\},\varnothing\rangle$,
which is then supplied to the below function.

\begin{definition}\label{def:insert}
  Let $t_0 = \langle R_0,M_0\rangle$ and $t_1 = \langle R_1,M_1\rangle$ be two trees. Function
  $\insertM$ of type $\gls{memtree}\times\gls{mem}\times\gls{predicate}\rightarrow\{\gls{mem}\}$
  is defined as follows:
  \begin{align*}
    \insertM(t_0,\varnothing) &\gls{defeq} \{t_0\}\notag \\
    \insertM(t_0,t_1\cons M) &\gls{defeq} \begin{cases}
      \insertM_\text{AL}(t_0,t_1,M) & \text{ if } t_0\gls{alias}t_1 \\
      \insertM_\text{SEP}(t_0,t_1,M) & \text{ if } t_0\gls{separate}t_1 \\
      \insertM_\text{ENC}(t_0,t_1,M) & \text{ if } t_0\gls{enclosed}t_1 \\
      \insertM_\text{CON}(t_0,t_1,M) & \text{ if } t_1\gls{enclosed}t_0 \\
      \mbox{destroy}(t_0, M)  & \text{otherwise}
    \end{cases}
  \end{align*}
  \todo{fix the formatting! though switching to equation* already got me halfway thebre}
  Notation $a \cons X$ denotes $\{a\} \cup X$ \todo{put this in glossary}.
  \begin{equation*}
    \begin{array}{lcl}
      \insertM_\text{AL}(t_0,t_1,M) &\gls{defeq}& \\
      \multicolumn{3}{r}{\{(R_0\cup R_1, M') \cons M \mid M' \in \mathsf{fold}(\insertM, M_0 \cup M_1) \}} \\
      \insertM_\text{SEP}(t_0,t_1,M) &\gls{defeq}& \{t_1\cons M'\mid M'\in\insertM(t_0,M)\} \\
      \insertM_\text{ENC}(t_0,t_1,M) &\gls{defeq}& \{\langle R_1,M'\rangle\cons M\mid M'\in\insertM(t_0,M_1)\} \\
      \insertM_\text{CON}(t_0,t_1,M) &\gls{defeq}& \\
      \multicolumn{3}{r}{ \{\insertM(t',M)\mid t'\in\{\langle R_0,M'\rangle\mid M'\in \insertM(t_1,M_0)\}\}}
    \end{array}
  \end{equation*}
\end{definition}
As further explanation, let $t_0 = \langle R_0,M_0\rangle$ be the tree to be inserted and $t_1 = \langle R_1,M_1\rangle$ be a tree already in the memory model.
\begin{enumerate}
  \item If~$t_0$ and~$t_1$ alias, then they are combined by taking the union of their nodes.
  Their child regions are not necessarily the same, however.
  Thus, subtrees are then reinserted using a $\mathsf{fold}$ \todo{change up this notation/styling}.
  \item If trees~$t_0$ and~$t_1$ are separate, then tree~$t_0$ is recursively inserted into the remainder of the memory model and~$t_1$ is added without modification.
  \item If~$t_0$ is enclosed in~$t_1$, it is recursively inserted into the sub-forest of~$t_1$.
  Each memory model~$M'$ thus obtained is wrapped in a tree $\langle R_1,M'\rangle$.
  The remainder of memory model~$M$ is unmodified.
  \item Finally, if $t_1$ is enclosed in $t_0$, then $t_1$ is recursively inserted into the sub-forest of $t_0$.
  Each memory model~$M'$ thus obtained is wrapped in a tree $t'=\langle R_0,M'\rangle$.
  That tree is then recursively inserted into memory model~$M$.
\end{enumerate}
\begin{example}\label{ex:example_snippet}
  Consider the three-instruction assembly snippet below.
  This snippet first stores the value \num{1000} in the eight-byte memory region
  pointed to by \rsi, then stores the value \num{1001}
  in the four-byte region pointed to by $\rsi+4$.
  Finally, it stores the value \num{1002} in the eight-byte region
  pointed to be \rsi.
  If the current state allows aliasing and separation between $\region\rdi8$ and $\region\rsi8$, then
  these three instructions will result in the two memory models in \cref{fig:mem}.
  Note that region $\region{\rsi+4}4$ is necessarily enclosed in region $\region\rsi8$.
  \begin{lstlisting}[style=x64]
    mov qword ptr [rdi],   1000
    mov dword ptr [rsi+4], 1001
    mov qword ptr [rsi],   1002
  \end{lstlisting}
\end{example}
A memory model~$M$ \emph{holds} in concrete state~$s$ if all siblings are separate and all trees hold.
A tree holds if its node contains only aliasing regions and all trees in its sub-forest are enclosed. Formally, this is expressed as:
\begin{definition}
  A memory model~$M$ \emph{holds} in state~$s$, notation $s\gls{holds}M$,
  if and only if:
  \begin{equation*}
    (\forall t_0, t_1\in M\sepdot t_0\neq t_1\implies s\gls{holds}t_0 \gls{separate}t_1) \wedge (\forall t\in M\sepdot s\gls{holds}t)
  \end{equation*}
  A memory tree~$t = \langle R,M\rangle$ \emph{holds} in state~$s$, notation $s\gls{holds}t$, if and only if:
  \begin{equation*}
    (\forall r_0,r_1 \in R\sepdot s\gls{holds}r_0\gls{alias}r_1) \wedge (\forall t'\in M\sepdot s\gls{holds}t'\gls{enclosed}t) \wedge (s\gls{holds}M)
  \end{equation*}
\end{definition}
\begin{example}
  Consider again the memory models in \cref{fig:mem}
  for the assembly snippet in \cref{ex:example_snippet}.
  The aliasing memory model in \cref{fig:memA}
  holds only in states where $\rdio=\rsio$.
  Meanwhile, the non-aliasing memory model in \cref{fig:memB}
  holds only in states where $\rdio+8\le\rsio$ or $\rsio+8\le\rdio$.
\end{example}

\todo{I changed up the wording but this still seems a bit abrupt, not sure how best to lead into the completeness discussion}
An important quality our insertion function must possess is \emph{completeness}.%
\index{completeness}
That is, the produced memory models should cover any possible relation between inserted region~$r$ and any region~$r'$ already present in the memory model.
To formulate completeness, we use~$R(M)$ to denote the set of regions in memory model~$M$ and $\mathcal{R}(M)$ to denote the set of relations.
\todo{I still want to revise this into my own words and notation if possible}
For example, we have $(\region\rdio8\gls{alias}\region\rsio8) \in \mathcal{R}(M)$ for the memory model in \cref{fig:memA}.

\todo{This lemma and proof are the most important things to put in my own words}
\begin{lemma}\label{lem:insert}
  Let~$r_0$ and~$M$ be a region and a memory model, respectively.
  Also let~$f$ of type $\mathbb{C} \times \mathbb{N} \mapsto \{ \gls{alias},  \gls{separate}, \gls{enclosed},\dotsc,\gls{encloses}\}$ be some mapping that provides a relation between~$r_0$ and~$r'$ for any region~$r'$ currently in memory model~$M$.
  Assume that $f$ is possibly true:
  \todo{glossary entry for $\models$}
  \begin{equation*}
    \exists s \sepdot s \gls{holds}M \wedge (\forall r' \in R(M) \sepdot s \models r_0~f(r')~r')
  \end{equation*}
  Then, insertion of region $r_0$ into $M$ will produce at least a corresponding memory model:
  \begin{equation*}
    \exists M' \in \insertM(\langle r_0,\varnothing\rangle,M) \sepdot \{ (r_0~f(r')~r') \mid r' \in R(M) \} \subseteq \mathcal{R}(M')
  \end{equation*}
  In words, there exists some memory model that contains all relations of mapping~$f$.
\end{lemma}
\begin{proof}
  The proof is by induction.
  The base case is trivial.
  For the inductive case, we insert region~$r$ into $\{t_1\} \cup M$.
  Four cases are possible:
  \begin{enumerate}[style=unboxed,leftmargin=0cm,labelindent=0pt,wide] % get too much sentence spacing with [wide, labelindent=0pt]
    \item Region $r_0$ necessarily aliases with $t_1$.
    In this case, since mapping $f$ is possibly true, it must assign \gls{alias} to all top-level regions of $t_1$, \gls{encloses} to all other regions in $t_1$ and \gls{separate} to all regions in $M$.
    The created memory model contains these relations.
    \item Region $r_0$ is necessarily separate from $t_1$.
    In this case, since mapping $f$ is possibly true, it must assign \gls{separate} to any region in $t_1$.
    Thus, tree $t_1$ is not modified and region $r_0$ is recursively inserted into $M$.
    The \ac{ih} then finishes the proof.
    \item Region $r_0$ is necessarily enclosed by a top-level region of $t_1$.
    Since mapping $f$ is possibly true, it must assign \gls{separate} to all regions of $M$.
    Therefore, the insertion function does not modify $M$.
    Since $r_0$ and $r_1$ do not alias, the top-level regions $R_1$ of tree $t_1$ can remain unmodified as well.
    Region $r_0$ is recursively inserted into a child of $t_1$, proof follows form the \ac{ih}.
    \item Tree $r_1$ is necessarily enclosed into region $r_0$.
    In this case, since mapping $f$ is possibly true, it must assign $\succeq$ to all regions of $t_1$.
    Therefore, tree $t_1$ is recursively inserted as subtree of $r_0$, producing a set of trees.
    For the remaining regions not in $t_1$, $f$ can hold arbitrary relations.
    Therefore any $t'$ in the produced set is recursively inserted into $M$.
    Again, the IH then finishes the proof.
    % \item No necessarily relation can be established. In that case, all of the above proofs apply, since memory models are generated for each possible case.
  \end{enumerate}
\end{proof}

\subsection{Joining}
As with state predicates, memory models have a join operation.
\begin{definition}\label{def:mem-join}
  The join of two memory models~$M_0$ and~$M_1$,
  notation $M_0\gls{join}M_1$, is recursively defined as:
  \begin{align*}
    M_0\gls{join}M_1 &\gls{defeq} \left\{ \join(T) \relmiddle| T\in\faktor{M_0 \cup M_1}{\gls{comparable}[^+]}\right\}\notag \\
    \langle R_0,.\rangle\gls{comparable}\langle R_1,.\rangle &\gls{defeq} R_0 \cap R_1\neq\varnothing\notag \\
    \join(T) &\gls{defeq} \left\langle\bigcap\{R\mid\langle R,.\rangle\in T\}, \bigsqcup\{M\mid\langle.,M\rangle\in T\}\right\rangle
  \end{align*}
\end{definition}
This operation partitions the memory trees in $M_0$ and $M_1$ based on
equivalence relation $\gls{comparable}[^+]$.
This equivalence relation is the transitive closure
of relation \gls{comparable}, which determines if
its two memory trees have any top-level regions in common.
In other words,
all memory trees that have one or more top-level regions in common are put in an equivalence class and are thus joinable.
The function $\join$ then performs the join operation
for each equivalence class of memory trees,
taking the intersection of all their region sets
and the supremum of their child memory models.
\begin{example}
  Consider two memory models~$M_0$ and~$M_1$ where both have the top node $\region\rdio8$.
  We add the distinction that~$M_0$ has an enclosed child $\region\rdio4$ and~$M_1$ has an enclosed child $\region{\rdio+4}4$. The result of joining~$M_0$ and~$M_1$ is a single memory model with $\region\rdio8$ as its top node and the two child regions in separate sibling nodes.
\end{example}

\begin{figure}
  \hspace*\fill
  \subcaptionbox{Alternate memory model\label{fig:otherMem}}{
    \hspace{3ex}
    \begin{tikzpicture}[>=stealth, every node/.style={draw}]
      \node (a) {$\{\region\rdio8,\region\rdxo8\}$};
    \end{tikzpicture}%
    \hspace{3ex}
  }
  \hfill
  \subcaptionbox{Join result\label{fig:otherMemJoin}}{
    \hspace{2ex}
    \begin{tikzpicture}[>=stealth, every node/.style={draw}]
      \node (a) {$\region\rdio8$};
    \end{tikzpicture}%
    \hspace{2ex}
  }
  \hspace*\fill
  \caption{Join with alternate memory model}\label{fig:otherJoin}
  %\Description{This shows an alternate memory model (on the left,
    %containing two eight-byte regions with separate symbolic variable bases)
    %that is joined with the memory model from Figure~\ref{fig:memA}
    %(where one of the top-level regions is shared),
    %resulting in the memory model shown on the right in the figure.
    %(only that shared top-level region is present)}
\end{figure}
\begin{example}
  First, consider the memory models shown in \cref{fig:mem}.
  Since the top nodes share a region, the two trees belong to the same equivalence class.
  The intersection of all of the region alias sets is:
  \begin{equation*}
    \{\region\rdio8,\region\rsio8\}\cap
    \{\region\rdio8\}\cap\{\region\rsio8\}.
  \end{equation*}
  As this intersection produces~$\varnothing$,
  the result of the join is~$\varnothing$, an empty memory model.
  Second, consider the join of the memory model shown in \cref{fig:memA}
  with the one shown in \cref{fig:otherMem}.
  The result of that join is the memory model shown in \cref{fig:otherMemJoin}.
  This is because all top-level memory trees involved in the merge share
  a region, $\region\rdio8$, but have no comparable children.
\end{example}

To strengthen our arguments, we prove that the join over memory models we have provided is sound.
\begin{lemma}\label{lem:mem_soundness}
  Let~$s$ be a state and~$M_0$ and~$M_1$ be memory models. Then:
  \begin{equation*}
    (s\models M_0 \vee M_1) \implies (s\models M_0\gls{join}M_1)
  \end{equation*}
\end{lemma}
\begin{proof}
  \todo{will look through this proof again for more my terms}
  Let $r_0\mathbin{\square}r_1$ be a relation in $\mathcal{R}(M_0\gls{join}M_1)$.
  If $\square$ is \gls{alias}, then both regions $r_0$ and $r_1$ must have been present in all trees in the corresponding equivalence class.
  The relation thus held in either $M_0$ or $M_1$.
  If $\square$ is \gls{separate}, then the two regions are from trees generated from different equivalence classes. Since they are from trees that do not share a top-level region, the original trees in either $M_0$ or $M_1$ are separate as well.
  Similar reasoning applies for the other cases.
\end{proof}

\begin{definition}
  \todo{did we introduce the \emph{symbolic} state terminology before this?}
  The join of two symbolic states $\sigma_0=\langle P_0,M_0\rangle$
  and $\sigma_1=\langle P_1,M_1\rangle$, notation $\sigma_0\gls{join}\sigma_1$, is:
  \begin{equation*}
    \sigma_0\gls{join}\sigma_1\gls{defeq}\langle P_0\gls{join}P_1,M_0\gls{join}M_1\rangle
  \end{equation*}
\end{definition}

Do keep in mind that this join in its full form \emph{loses} information.
It can thus only be applied in a sound fashion for postcondition weakening \autocite{hoare1969axiomatic}.
In other words, dropping clauses and performing state cleanup
serve only to reduce state constraints; they never add additional ones.
In practice, this loss of information means that we may produce a state
that would not actually be encountered during program execution.
Alternatively, we may be unable to resolve some indirections or prove some return addresses, which would result in additional annotations generated or even tool failure.
Despite this, in cases with successful completion and no annotations produced,
we will always produce all states that would be encountered during concrete execution.

\section{Base Algorithm}
\todo{maybe move this to Technical Formulation?}
\Ac{hg}

\section{Extension: Function Calls}

\subsection{External Functions}

\subsection{Internal Functions}
