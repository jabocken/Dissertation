\chapter{Exceptional Interprocedural Control Flow Graphs}\label{ch:eicfg}
\todo{intro!}

A normal \ac{cfg} provides a user with information on control flow transfers induced by \emph{jumps} and \emph{calls}.
Given a specific jump or call instruction, one can look up in the \ac{cfg} the set of successor instructions and the information on which that successor selection is based.
For sets with more than one element, such decisions are typically represented by expressions over flags (for example, $\mathasm{CF}$ and $\mathasm{ZF}$ for the carry and zero flag) or a jump table calculation.

The labels of \iac{cfg} can be seen as \emph{state predicates}.
That is, when an edge is labeled with a flag such as \inlineasm{ZF},
that notation can be seen as a predicate on the value of the zero flag in the state of the originating node.
More complex predicates can consist of logical expressions such as $\mathasm{CF}\land\mathasm{ZF}$, which checks if both \inlineasm{CF} and \inlineasm{ZF} are set.
Higher-level predicates can have clauses such as $\mathasm{rax}=0$ or $\mathasm{DWORD PTR [rdi]}<5$.

However, traditional \acp{cfg} produced by existing static analysis tools lack information on interprocedural indirect control flow.
This includes stack unwinding due to exception throwing, try-catch handling, and \Cpp-style object cleanup.
This information is not present because their analyses do not model the semantics of throw operations, even when static try-catch information is available.

A summarized reproduction of the interprocedural control flow graph
% from \cref{sec:example}
%from \cref{sec:eicfg}
generated by Ghidra for an example program can be seen in \cref{fig:ghidra-example}.
While Ghidra can identify catch and cleanup landing pads (\texttt{foo'}, \texttt{bar'}, and \texttt{catch}), it cannot directly show that the throws in \inlineasm{foo} and \inlineasm{bar} will unwind there.
Furthermore, it does not show that \inlineasm{foo} and \inlineasm{bar} can be indirectly called from \inlineasm{main}.
The diamond in the graph indicates the indirect call location, but the only edge from it is the edge after its return (to a triangle).
%By contrast, we can show both the edges from the throws to their handling sites, if present, as well as the potential function calls via jump table.
IDA Pro and Binary Ninja produce similar results; they can identify landing pad locations intraprocedurally, but they cannot trace exceptional control flow interprocedurally.
We have verified that this holds for more complicated programs as well (some of the programs used in \cref{sec:case-study}).

% graphdrawing library gives better automatic arrangements but requires LuaLaTeX and I don't know if IEEE Transactions or LNCS support that. Could use for dissertation though.
\begin{figure}
  \centering
  \begin{tikzpicture}
    \graph[grow down=0.7cm,branch right,nodes={draw,ellipse,font=\footnotesize\ttfamily}]{
      foo -> fEnd1/""[ret],
      foo -> "" -> {fEnd1, fEnd2/""[ret]}, % more compact this way
      foo'[landing] -> fEnd'/""[ret],

      bar -> {b1/"", bEnd1/""[ret,< draw=none]} -> {b2/"", bEnd2/""[ret]},
      b2 -> {bar[> bend left], bEnd2},
      b1 -> bEnd2, % necessary due to group/chain interactions
      bar'[landing] -> bEnd'/""[ret],

      {[grow down=.9cm, branch right=1.2cm]
        {main[circle], catch[landing]} -> {
          callSite/""[diamond],
          ""[at=(0:-.25)],
          ""[ret, bad, at=(0:-.7), < draw=none]
        } -> ""[ret,good],
      };

      callSite ->[dashed,red] foo;
      callSite ->[dashed,red] bar;

      fEnd1 ->[dashed,red] callSite;
      bEnd2 ->[dashed,red] callSite;

      fEnd2 ->[unwind] foo'; fEnd' ->[unwind] catch;
      bEnd1[< draw] ->[unwind] bar'; bEnd' ->[unwind] catch; % Had to reenable bEnd1's ability to draw outgoing edges here as setting it on the edge itself didn't work.
    };
  \end{tikzpicture}
  \caption{Ghidra-generated graph (summarized) with basic EICFG edges added.}\label{fig:ghidra-example}
\end{figure}

Therefore, we produce \iac{eicfg}, which augments a normal \ac{cfg} with edges produced by try, catch, and throw behavior.
Specifically, it contains the edges for control flow produced by the execution of the compiled form of the \Cpp{} \lstinline{throw} command.
These additional edges are the dotted blue ones in \cref{fig:ghidra-example}.
We also illustrate the edges for standard interprocedural control flow as dashed red ones.

Instead of simple labels, \acp{eicfg} use \emph{exceptional state predicates} as labels.
%A formal definition will follow in \cref{sec:abstract-state}.
Informally, the information on which exceptional control flow is based is:
\begin{enumerate*} % inline enum for space
  \item the exception object, e.g., type info and rethrown state;
  \item the current set of return addresses on the stack;
  \item the current uncaught exception count;
  \item the current caught exception stack; and
  \item a static address (landing pad) table for the unwinding process.
\end{enumerate*}
Exception type info is used to determine which catch blocks, if any, are applicable to the exception being thrown.
Rethrown status is necessary when determining behavior when dealing with the binary equivalent of an argumentless \lstinline{throw}.
The return address stack is necessary to provide context for unwinding.
The uncaught exception count keeps track of how many thrown exceptions are currently uncaught.
This is useful for diagnostic information.
Next, the caught exception stack provides information to set up implicit rethrowing.
Finally, the landing pad table ($\landingpadtable$) maps from potential unwind spots in a binary to locations where unwinding can exit.

\begin{definition}
  An \emph{exceptional state predicate} is based on an exception object~$E$, a return address stack~$R$, uncaught exception count~$u$, and caught exception stack~$C$.
  It is a predicate that, given a state, checks the following things:
  \begin{itemize}
    \item Is the current exception object equal to $E$?
    \item Is the current return address stack equal to $R$?
    \item Is the current uncaught exception count equal to $u$?
    \item Is the current caught exception stack equal to $C$?
    \item \todo{landing pad table}
  \end{itemize}
\end{definition}

\begin{example}
  Consider the catch statement on \cref{lst:catch} of \cref{lst:example}.
  Control flow will reach the contents of that catch statement's block if and only if the exceptions propagated to the corresponding \lstinline|try| block are instances of \lstinline|std::exception| or a subclass.
\end{example}
\begin{lstlisting}[
  float,
  gobble=2,
  numbers=left,
  caption=Example program,
  label=lst:example
]
  #include <stdexcept>

  int foo(int x) {
    if (x < 0) return x;
    while (x > 0) {
      x--;
      if (x == 5)
      throw std::domain_error("5"); |\label{lst:throw}|
    }
    return 0;
  }

  int bar(int x) {
    if (x < 0)
    throw std::out_of_range("negative");
    else if (x == 0) return 1;
    return x * bar(x - 1); |\label{lst:recursion}|
  }

  int (*const FOOBAR[])(int) = {foo, bar};|\label{lst:indirection}|

  int main(int argc, char* argv[]) {
    try { |\label{lst:try-catch}|
      if (argc < 2) |\label{lst:example-bounds-check}|
      return FOOBAR[argc](argc); |\label{lst:example-source-indirect-call}|
    } catch (const std::exception&) {|\label{lst:catch}|
      if (argc < 0) throw; |\label{lst:source-rethrow}|
      return 0; |\label{lst:good-termination}|
    }
  }
\end{lstlisting}

We here provide a formal definition of an EICFG.
\begin{definition}\label{def:eicfg}
  \Iac{eicfg} is a directed graph with instruction addresses as vertices and edges labelled with exceptional state predicates.
  %    Instruction addresses are pointers of type $\pointer$.
  There is an edge between instruction addresses $a_0$ and $a_1$ with label $P$ if the instruction at address $a_0$ leads to instruction address $a_1$ for any state that satisfies predicate $P$.
\end{definition}

% \section{Running Example}\label{sec:example} % Shouldn't have only one section in a chapter
\begin{figure}
  \centering
  \begin{tikzpicture}[every node/.style={node font=\ttfamily}]
    \graph[grow down=1.25cm,branch right=4cm,nodes=draw]{
      0x1286 ->["$\begin{array}{l}
        \stack=[\mathtt{0x137e},\mathtt{0x116e}]\\
        \landingpadtable(\mathtt{0x1286})=\varnothing
      \end{array}$",unwind] 0x137e ->["$\begin{array}{l}
        \stack=[\mathtt{0x116e}]\\
        \landingpadtable(\mathtt{0x137e})=\{\mathtt{0x138b}\}
      \end{array}$",unwind] "\texttt{0x138b}--\texttt{0x1393}"[font=\normalfont] -> {
        "\texttt{0x1395}--\texttt{0x1398}"[>"!ZF"',font=\normalfont] ->["$\begin{array}{l}
          \stack=[\mathtt{0x116e}]\\
          \landingpadtable(\mathtt{0x1398})=\varnothing
        \end{array}$",unwind] t1/0x116e[bad],
        0x139d[>"ZF"] ->["$\stack=[\mathtt{0x116e}]$",loosely dotted] 0x13dd ->["$\stack=[\mathtt{0x116e}]$",dashed] t2/0x116e[good]
      }
    };
  \end{tikzpicture}
  \caption{Throwing an exception.}\label{fig:example-unwinding}
\end{figure}
% It's annoying but I have to compress the assembly all the way if I want to include the annotations
\begin{lstlisting}[
  %    float,
  style=x64,
  gobble=4,
  multicols=2, % apparently you sometimes have to include the multicol package explicitly?
  basicstyle=\scriptsize\ttfamily, % needed to fit things in more compactly with multicols in LNCS format!
  caption=Example throw.,
  label=lst:example-throw
  ]
  125b:call 10d0 <__cxa_allocate_exception|\label{lst:example-allocate}|
  1260:mov rbx,rax |\label{lst:example-throw-move}|
  1263:lea rsi,[rip+0xd9b] # 2005
  126a:mov rdi,rbx
  126d:call 10e0#std::domain_error init |\label{lst:example-initialize}|
  1272:mov rax,QWORD PTR [rip+0x2d4f] |\label{lst:example-global-read}|
  1279:mov rdx,rax
  127c:lea rsi,[rip+0x2abd] # 3d40
  1283:mov rdi,rbx
  1286:call 1120 <__cxa_throw |\label{lst:example-throw-call}|
  ...
  129c:call 10f0 <__cxa_free_exception |\label{lst:example-free}|
\end{lstlisting}
Some of the additional information provided by \iac{eicfg} is illustrated in \cref{fig:example-unwinding},
which models the process of throwing an exception from the same example program as \cref{fig:ghidra-example}.
The representation in the figure indicates the process of unwinding from one throw site in the control flow graph to a try-catch block or cleanup landing pad.
This path was triggered by the snippet of assembly shown in \cref{lst:example-throw}, which allocates (\instref{lst:example-allocate}{125b}), initializes (\instref{lst:example-initialize}{126d}), and throws (\instref{lst:example-throw-call}{1286}) an exception.
The landing pad table of the binary, $\landingpadtable$, directs the unwinding process:
when stack unwinding reaches address~$i$ and $j\in\landingpadtable(i)$,
control flow branches to address~$j$.
Otherwise, another frame is popped off the stack.
This will be elaborated on in
%\cref{sec:landing-pad-table}.
\cref{sec:abstract-state}.
For this example, we get unwinding from address (\instref{lst:example-throw-call}{1286}) to
%\instref{lst:unwind-site}{137e}
\inlineasm{0x137e}
to \instref{lst:landing-pad}{138b}.

Due to overapproximation, there are two possible paths from that point.
One is the path for an exception object that is not of the caught type,
some checks of which occur via the assembly instructions \instref{lst:assembly-type-check}{138f} and \instref{lst:assembly-type-jump}{1393} of \cref{lst:example-throw-landing-pad}.
This path results in unwinding being resumed (\instref{lst:unwind-resume}{1398}) and leads to a bad termination case at instruction \instref{lst:example-hlt}{116e}.
The other path continues from node \instref{lst:matching-catch-target}{139d}.
It eventually leads to \instref{lst:example-hlt}{116e} from \instref{lst:example-ret}{13dd} (intervening nodes elided).
This is a good termination case as reaching that halting instruction occurred outside unwinding.

\begin{figure}
  \centering
  \begin{tikzpicture}[every node/.style={node font=\ttfamily}]
    \graph[grow down=.9cm,branch right=4cm,nodes=draw]{
      0x135f -> {
        a1/"[0x1362,0x137a]"[>"$j=0$"'] ->["$j=0$"'] a2/0x137c ->["\inlineasm{call tbl[0]}"', dashed] "[0x12b5,0x12cb]",
        b1/"[0x1362,0x137a]"[>"$j=1$"] ->["$j=1$"] b2/0x137c ->["\inlineasm{call tbl[1]}", dashed] "[0x1229,0x123f]"
      }
    };
  \end{tikzpicture}
  \caption{Identifying indirection.}\label{fig:example-indirect-call}
\end{figure}
Meanwhile, indirect function call resolution is shown in \cref{fig:example-indirect-call}, which is a representation of \cref{lst:example-indirect-call}.
This process occurs when we detect a value being read from a part of the state
that is positively bounded, because such values may be jump table indices.
In the given example, that bound is provided by a conditional check previously (instructions \instref{lst:example-cmp}{1359} and \instref{lst:example-conditional-jump}{135d} of \cref{lst:example-indirect-call}).
When this happens and the state part being read from does not already have a fixed value, we generate non-deterministic edges where the read value ranges from 0 to the upper bound.
This can be seen in the middle graph edges of \cref{fig:example-indirect-call},
which connect the same addresses but have different jump table indices.
In the compiled assembly of the program, the jump table index selection occurs at \instref{lst:example-jump-table-index}{135f}.
Such values can then be used later on in the calculation of jump table addresses, in this case by \instref{lst:example-jumptable-read}{136c} and \instref{lst:example-jumptable-calculate}{1373}.
This non-deterministically results in \instref{lst:example-indirect-call-call}{137c} going to different address ranges, as shown in the graph.

% replacing the tabs with spaces to try to compress things
\begin{lstlisting}[
  %    float,
  style=x64,
  gobble=4,
  multicols=2,
  basicstyle=\scriptsize\ttfamily, % needed to fit things in more compactly with multicols in LNCS format!
  caption=Example throw landing pad.,
  label=lst:example-throw-landing-pad
  ]
  1387: mov eax,ebx
  1389: jmp 13d7 <main+0x92>
  138b: endbr64 |\label{lst:landing-pad}|
  138f: cmp rdx,0x1 |\label{lst:assembly-type-check}|
  1393: je 139d <main+0x58> |\label{lst:assembly-type-jump}|
  1395: mov rdi,rax
  1398: call 1130 <_Unwind_Resume |\label{lst:unwind-resume}|
  139d: mov rdi,rax |\label{lst:matching-catch-target}|
  13a0: call 10c0 <__cxa_begin_catch |\label{lst:begin-catch}|
  13a5: mov QWORD PTR [rbp-0x18],rax
  13a9: cmp DWORD PTR [rbp-0x24],0x0
  13ad: jns 13b4 <main+0x6f>
  13af: call 1100 <__cxa_rethrow |\label{lst:assembly-rethrow}|
  13b4: mov ebx,0x0
  13b9: call 1110 <__cxa_end_catch |\label{lst:end-catch}|
  13be: jmp 1387 <main+0x42>
  13c0: endbr64
  ...
  13d7: add rsp,0x28
  13db: pop rbx
  13dc: pop rbp
  13dd: ret |\label{lst:example-ret}|
\end{lstlisting}
\begin{lstlisting}[
  %    float,
  style=x64,
  gobble=4,
  multicols=2,
  basicstyle=\scriptsize\ttfamily, % needed to fit things in more compactly with multicols in LNCS format!
  caption=Example indirect call.,
  label=lst:example-indirect-call
  ]
  1359: cmp DWORD PTR [rbp-0x24],0x1 |\label{lst:example-cmp}|
  135d: jg 1382 <main+0x3d> |\label{lst:example-conditional-jump}|
  135f: mov eax,DWORD PTR [rbp-0x24] |\label{lst:example-jump-table-index}|
  1362: cdqe
  1364: lea rdx,[rax*8+0x0]
  136c: lea rax,[rip+0x29ad] # 3d20 |\label{lst:example-jumptable-read}|
  1373: mov rdx,QWORD PTR [rdx+rax*1] |\label{lst:example-jumptable-calculate}|
  1377: mov eax,DWORD PTR [rbp-0x24]
  137a: mov edi,eax
  137c: call rdx |\label{lst:example-indirect-call-call}|
  137e: mov ebx,eax |\label{lst:unwind-site}|
\end{lstlisting}
\begin{lstlisting}[
  %    float,
  style=x64,
  gobble=4,
  multicols=2,
  basicstyle=\scriptsize\ttfamily, % needed to fit things in more compactly with multicols in LNCS format!
  caption=The \texttt{\_start} function,
  label=lst:example-start
  ]
  1140:endbr64 |\label{lst:start-first}|
  1144:xor ebp,ebp |\label{lst:example-clear-reg}|
  1146:mov r9,rdx |\label{lst:example-start-move}|
  1149:pop rsi
  114a:mov rdx,rsp
  114d:and rsp,0xfffffffffffffff0
  1151:push rax
  1152:push rsp
  1153:lea r8,[rip+0x2f6] # 1450
  115a:lea rcx,[rip+0x27f] # 13e0
  1161:lea rdi,[rip+0x1dd] # 1345<main>
  1168:call QWORD PTR [rip+0x2e6a]#3fd8|\label{lst:example-libc}|
  116e:hlt |\label{lst:example-hlt}|
\end{lstlisting}
% |\label{lst:good-termination}|
