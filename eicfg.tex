\chapter{Exceptional Interprocedural Control Flow Graphs}\label{ch:eicfg}
\acreset{eicfg}

\todo{Full intro in progress/revising and replacing with putting my text back}

\section{Introduction}

% CONTEXT: CFGs are important + we reconstruct them from binaries
% NOTE: in terms of academic writing, we have paragraph with two messages here (which should be 1). However, we are strapped for space.
\Acp{cfg} are key components in both compilation and analysis of software.
They provide information on the runtime execution of a program, i.e., which control flow paths are dynamically possible.
Typically, they are constructed during compilation using the source code as ground truth.
In the field of binary analysis, however, they must be \emph{reconstructed} from a binary.
This is a challenge, since control flow transfers may be \emph{indirect}, i.e., their jump target may be resolved at runtime.
This makes generating \iac{cfg} an undecidable problem, as it must be decided what the exact values of certain state parts can be at runtime.


% CHALLENGE: EXCEPTIONAL CONTROL FLOW
This problem is exacerbated when dealing with \emph{exceptional control flow}, induced mainly by the \Cpp{} \lstinline{throw} and \lstinline{catch} statements.
The target of a throw, i.e., to which instruction address the control flow is transferred after execution of a throw statement, is decided dynamically at runtime.
It is based on, among other things, the current call/return stack, the current caught exception stack, and low-level information pertaining to rethrows and catch statements.
Moreover, it inherently requires \emph{interprocedural} analysis, as the function call history is relevant for assessing the throwsâ€™ targets.
Interprocedural analysis is challenging, as one cannot simply isolate a function and do analysis, but most consider the binary as a whole.


% EXISTING TOOLS DO NOT SOLVE THE PROBLEM
Existing state-of-the-art disassemblers/decompilers, such as IDA Pro, Ghidra, and Binary Ninja, do not provide sufficient information on exceptional control flow.
Typically, they are able to extract exception information statically available in binaries (e.g., landing pad locations).
They can even provide interprocedural control flow graphs.
However, they do not perform the interprocedural static analysis required for reconstructing \emph{exceptional} control flow.
That is, they cannot trace the path from an exception throw site to the landing pad instructions that exception goes to in the process of unwinding.
\Acp{cfg} under such analyses will have \emph{throw sites as terminating locations} with no outgoing edges.
%Tracing an exception from throw site to catch is not a feature of such tools.
%In order to analyze the stack unwinding caused by an exception being thrown, one must typically utilize a runtime debugger such as GDB.
%In fact, many state-of-the- art disassembly tools, IDA Pro and Ghidra included, rely on GDB to perform dynamic analysis via debugging.
%That is, they require runtime information in order to trace exceptional state.

% OUR CONTRIBUTION
This paper provides a tool for static, interprocedural, automated \Cpp-exception-aware control flow analysis on the binary level.
That tool produces \acp{eicfg}, that document the direct exception-handling-related components of the state of the program, such as exception objects currently allocated, number of uncaught exceptions, and which exceptions are currently in a caught state.


The tool itself targets binaries using \Cpp\ exception handling%
\fturl{https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html}
that were compiled for the \gls{arch} \ac{isa} and System~V \ac{abi}.
Symbol-stripped binaries are supported, but may not perform well if they contain unresolvable indirections or unmodeled callbacks.
Non-\Cpp\ binaries, or \Cpp\ ones that do not use exception handling, are supported as well for flexibility.
We assume that all external calls do not produce exceptions themselves.
We also do not model \lstinline{setjmp}/\lstinline{longjmp}, as they do not interact well with structured exception handling \autocite{using-setjmp-and-longjmp}.

% VALIDATION
A desired characteristic is that the produced \acp{eicfg} are \emph{overapproximative}: every concrete path, i.e., every path possible during dynamic execution, is included in the \ac{eicfg}.
We informally argue that the abstract semantics that are symbolically executed overapproximate the concrete semantics \autocite{cousot1996abstract}.
To strengthen this claim, we validated our abstract transition rules for exception handling against the concrete implementations of the corresponding library functions.
This was done by fuzzing abstract states, concretization to a concrete CPU state, running the function under validation in an instrumented binary, observing the CPU state, and verifying that the concrete transition is correctly contained in the abstract transition.
%This was done by \emph{fuzzing} dynamically instrumented test binaries using generated abstract start and end states.
We informally argue that our approach is overapproximative unless an indirection cannot be resolved, which is clearly marked in the \ac{eicfg}.
%The methodology is informally based on abstract interpretation \autocite{cousot1996abstract}, where an abstract transition relation overapproximates concrete transitions.


\subsection{Results and Organization}
% RESULTS
We applied the tool to \totalbins\ off-the-shelf binaries compiled from \Cpp, C, and Fortran source code.
%The implemented tool was able to reach an average of \coveredpercent\ of the instructions from the \satisfactorybins\ binaries we examined that had satisfactory analyses (for our purposes, \cutoffpercent).
The implemented tool was able to identify \uniquethrows\ unique throws and successfully trace the exceptional control flow for every one of them.
On average, dealing with exceptional control flow can increase coverage by \avgdiffinst\ per unique throw, with each throw averaging \avgunwinds\ unwind edges.
Those edges are ones tools such as Ghidra do not produce.

% ORGANIZATION
We explain the contribution by example in \cref{sec:eicfg}.
The technical formulation of our tool is then outlined in \cref{sec:formulation},
with validation in \cref{sec:validation} and a demonstration following in \cref{sec:case-study}.
Specifically, we demonstrate that \acp{eicfg} provide improved coverage compared to a non-exceptional baseline analysis.
In \cref{sec:related} we discuss related work.
Finally, we wrap up in \cref{sec:conclusion}.

All code used for \cref{sec:case-study,sec:validation}, to be published as an artifact, is available at \url{https://drive.google.com/file/d/1mFjHT0p-w9YbyRjcBCQ8sPHp3eboUdM2/view?usp=sharing}.

\begin{comment}
  Static program analysis is a difficult task, made even harder when the well-established
  stack-based function call paradigm is not respected. In particular,
  exception handling often includes violations of program control flow not visible
  from within the source code or binary of the program.
  Even structured exception handling, such as that provided by \Cpp,
  requires information external to the binary in order to properly analyze it.
  Modeling this information requires, at a minimum,
  semantics for the library functions that perform the exception handling process.

  \subsection{Contribution}
  This paper provides a tool for static, interprocedural,
  \Cpp-exception-aware control flow analysis.
  Specifically, the production of \acp{eicfg}.
  It can do this even in the presence of recursion and some forms of indirect control flow.
  The tool is guaranteed to provide overapproximative results for those paths of execution it can resolve, with those paths it cannot resolve clearly marked in its output.
  The resulting \ac{eicfg} documents the direct exception-handling-related components of the state of the program, such as exception objects currently allocated, number of uncaught exceptions, and which exceptions are currently in a caught state.
  This is done using an abstract interpretation-based methodology in a restricted domain that only concerns itself with the necessary components of program state required to perform function calls and exception handling.

  \todo\dots

  It operates using a recursive-descent rather than linear sweep methodology.

  \subsection{Motivation}
  \Acp{eicfg}

  Overapproximativity is necessary in order to provide complete coverage.
  Alternate methods of uncovering exceptional state generally rely on

  Interprocedural analysis is necessary as exception handling is inherently interprocedural. While

  \todo{needs more work}

  The information necessary for stack unwinding can be embedded within a program.
  Debugging builds have it to provide support for unwinding during debugging.
  Programs with structured exception handling require it even when debugging information
  is excluded. However, even when such information exists, its support for interprocedural
  analysis applies solely to the act of stack unwinding. Investigating the behavior of
  exception handling in such scenarios requires the implementation of handling
  for multiple runtime library functions.
  These include \inlineasm{__cxa_throw}, \inlineasm{__cxa_begin_catch},
  and \inlineasm{__cxa_end_catch}.

  \subsection{Relation to State of the Art}
  To the best of our knowledge, we are the first to provide a generator for
  \ac{eicfg}-like constructs on the binary level.
  Many state-of-the-art disassemblers/decompilers, such as IDA Pro, Ghidra, and Binary Ninja,
  can extract exception information from binaries, including landing pad locations.
  They can even provide interprocedural control flow graphs.
  However, they do not provide features for interprocedural exception analysis.
  Tracing an exception from throw site to catch is not a feature of such tools.
  In order to analyze the stack unwinding caused by an exception being thrown,
  one must typically utilize a runtime debugger such as GDB.
  In fact, many state-of-the-art disassembly tools, IDA Pro and Ghidra included,
  rely on GDB to perform dynamic analysis via debugging.
  That is, they require runtime information in order to trace exceptional state.
  In contrast, our \ac{eicfg} generator does not.

  \subsection{Organization}
  For easier explanations,
  we provide a running example referenced throughout this work in \cref{sec:example}.
  The technical formulation of our tool is then outlined in \cref{sec:formulation},
  with a demonstration following in \cref{sec:case-study}.
  Next, in \cref{sec:related}, is a fleshed-out description of related tools.
  Finally, we wrap up in \cref{eicfg-conclusion}.
\end{comment}

\section{Extended Motivation}
A normal \ac{cfg} provides a user with information on control flow transfers induced by \emph{jumps} and \emph{calls}.
Given a specific jump or call instruction, one can look up in the \ac{cfg} the set of successor instructions and the information on which that successor selection is based.
For sets with more than one element, such decisions are typically represented by expressions over flags (for example, $\mathasm{CF}$ and $\mathasm{ZF}$ for the carry and zero flag) or a jump table calculation.

The labels of \iac{cfg} can be seen as \emph{state predicates}.
That is, when an edge is labeled with a flag such as \inlineasm{ZF},
that notation can be seen as a predicate on the value of the zero flag in the state of the originating node.
More complex predicates can consist of logical expressions such as $\mathasm{CF}\land\mathasm{ZF}$, which checks if both \inlineasm{CF} and \inlineasm{ZF} are set.
Higher-level predicates can have clauses such as $\mathasm{rax}=0$ or $\mathasm{DWORD PTR [rdi]}<5$.

However, traditional \acp{cfg} produced by existing static analysis tools lack information on interprocedural indirect control flow.
This includes stack unwinding due to exception throwing, try-catch handling, and \Cpp-style object cleanup.
This information is not present because their analyses do not model the semantics of throw operations, even when static try-catch information is available.

A summarized reproduction of the interprocedural control flow graph
% from \cref{sec:example}
%from \cref{sec:eicfg}
generated by Ghidra for an example program can be seen in \cref{fig:ghidra-example}.
While Ghidra can identify catch and cleanup landing pads (\texttt{foo'}, \texttt{bar'}, and \texttt{catch}), it cannot directly show that the throws in \inlineasm{foo} and \inlineasm{bar} will unwind there.
Furthermore, it does not show that \inlineasm{foo} and \inlineasm{bar} can be indirectly called from \inlineasm{main}.
The diamond in the graph indicates the indirect call location, but the only edge from it is the edge after its return (to a triangle).
%By contrast, we can show both the edges from the throws to their handling sites, if present, as well as the potential function calls via jump table.
IDA Pro and Binary Ninja produce similar results; they can identify landing pad locations intraprocedurally, but they cannot trace exceptional control flow interprocedurally.
We have verified that this holds for more complicated programs as well (some of the programs used in \cref{sec:case-study}).

% graphdrawing library gives better automatic arrangements but requires LuaLaTeX and I don't know if IEEE Transactions or LNCS support that. Could use for dissertation though.
\begin{figure}
  \centering
  \begin{tikzpicture}
    \graph[grow down=0.7cm,branch right,nodes={draw,ellipse,font=\footnotesize\ttfamily}]{
      foo -> fEnd1/""[ret],
      foo -> "" -> {fEnd1, fEnd2/""[ret]}, % more compact this way
      foo'[landing] -> fEnd'/""[ret],

      bar -> {b1/"", bEnd1/""[ret,< draw=none]} -> {b2/"", bEnd2/""[ret]},
      b2 -> {bar[> bend left], bEnd2},
      b1 -> bEnd2, % necessary due to group/chain interactions
      bar'[landing] -> bEnd'/""[ret],

      {[grow down=.9cm, branch right=1.2cm]
        {main[circle], catch[landing]} -> {
          callSite/""[diamond],
          ""[at=(0:-.25)],
          ""[ret, bad, at=(0:-.7), < draw=none]
        } -> ""[ret,good],
      };

      callSite ->[dashed,red] foo;
      callSite ->[dashed,red] bar;

      fEnd1 ->[dashed,red] callSite;
      bEnd2 ->[dashed,red] callSite;

      fEnd2 ->[unwind] foo'; fEnd' ->[unwind] catch;
      bEnd1[< draw] ->[unwind] bar'; bEnd' ->[unwind] catch; % Had to reenable bEnd1's ability to draw outgoing edges here as setting it on the edge itself didn't work.
    };
  \end{tikzpicture}
  \caption{Ghidra-generated graph (summarized) with basic EICFG edges added.}\label{fig:ghidra-example}
\end{figure}

\section{Further Discussion of Contribution}
Therefore, we produce \iac{eicfg}, which augments a normal \ac{cfg} with edges produced by try, catch, and throw behavior.
Specifically, it contains the edges for control flow produced by the execution of the compiled form of the \Cpp{} \lstinline{throw} command.
These additional edges are the dotted blue ones in \cref{fig:ghidra-example}.
We also illustrate the edges for standard interprocedural control flow as dashed red ones.

Instead of simple labels, \acp{eicfg} use \emph{exceptional state predicates} as labels.
%A formal definition will follow in \cref{sec:abstract-state}.
Informally, the information on which exceptional control flow is based is:
\begin{enumerate}
  \item the exception object, e.g., type info and rethrown state;
  \item the current set of return addresses on the stack;
  \item the current uncaught exception count;
  \item the current caught exception stack; and
  \item a static address (landing pad) table for the unwinding process.
\end{enumerate}
Exception type info is used to determine which catch blocks, if any, are applicable to the exception being thrown.
Rethrown status is necessary when determining behavior when dealing with the binary equivalent of an argumentless \lstinline{throw}.
The return address stack is necessary to provide context for unwinding.
The uncaught exception count keeps track of how many thrown exceptions are currently uncaught.
This is useful for diagnostic information.
Next, the caught exception stack provides information to set up implicit rethrowing.
Finally, the landing pad table ($\landingpadtable$) maps from potential unwind spots in a binary to locations where unwinding can exit.

\begin{definition}[Exceptional State Predicate]
  An \emph{exceptional state predicate} is based on an exception object~$E$, a return address stack~$R$, uncaught exception count~$u$, and caught exception stack~$C$.
  It is a predicate that, given a state, checks the following things:
  \begin{itemize}
    \item Is the current exception object equal to $E$?
    \item Is the current return address stack equal to $R$?
    \item Is the current uncaught exception count equal to $u$?
    \item Is the current caught exception stack equal to $C$?
    \item \todo{landing pad table}
  \end{itemize}
\end{definition}

\begin{example}[Try and Catch]
  Consider the catch statement on \cref{lst:catch} of \cref{lst:example}.
  Control flow will reach the contents of that catch statement's block if and only if the exceptions propagated to the corresponding \lstinline|try| block are instances of \lstinline|std::exception| or a subclass.
\end{example}
\begin{lstlisting}[
  float,
  gobble=2,
  numbers=left,
  caption=Example program,
  label=lst:example
]
  #include <stdexcept>

  int foo(int x) {
    if (x < 0) return x;
    while (x > 0) {
      x--;
      if (x == 5)
      throw std::domain_error("5"); |\label{lst:throw}|
    }
    return 0;
  }

  int bar(int x) {
    if (x < 0)
    throw std::out_of_range("negative");
    else if (x == 0) return 1;
    return x * bar(x - 1); |\label{lst:recursion}|
  }

  int (*const FOOBAR[])(int) = {foo, bar};|\label{lst:indirection}|

  int main(int argc, char* argv[]) {
    try { |\label{lst:try-catch}|
      if (argc < 2) |\label{lst:example-bounds-check}|
      return FOOBAR[argc](argc); |\label{lst:example-source-indirect-call}|
    } catch (const std::exception&) {|\label{lst:catch}|
      if (argc < 0) throw; |\label{lst:source-rethrow}|
      return 0; |\label{lst:good-termination}|
    }
  }
\end{lstlisting}

We here provide a formal definition of \iac{eicfg}.
\begin{definition}[EICFGs]\label{def:eicfg}
  \Iac{eicfg} is a directed graph with instruction addresses as vertices and edges labelled with exceptional state predicates.
  %    Instruction addresses are pointers of type $\pointer$.
  There is an edge between instruction addresses $a_0$ and $a_1$ with label $P$ if the instruction at address $a_0$ leads to instruction address $a_1$ for any state that satisfies predicate $P$.
\end{definition}

\section{Running Example}\label{sec:example}
\begin{figure}
  \centering
  \begin{tikzpicture}[every node/.style={node font=\ttfamily}]
    \graph[grow down=1.25cm,branch right=4cm,nodes=draw]{
      0x1286 ->["$\begin{array}{l}
        \stack=[\mathtt{0x137e},\mathtt{0x116e}]\\
        \landingpadtable(\mathtt{0x1286})=\varnothing
      \end{array}$",unwind] 0x137e ->["$\begin{array}{l}
        \stack=[\mathtt{0x116e}]\\
        \landingpadtable(\mathtt{0x137e})=\{\mathtt{0x138b}\}
      \end{array}$",unwind] "\texttt{0x138b}--\texttt{0x1393}"[font=\normalfont] -> {
        "\texttt{0x1395}--\texttt{0x1398}"[>"!ZF"',font=\normalfont] ->["$\begin{array}{l}
          \stack=[\mathtt{0x116e}]\\
          \landingpadtable(\mathtt{0x1398})=\varnothing
        \end{array}$",unwind] t1/0x116e[bad],
        0x139d[>"ZF"] ->["$\stack=[\mathtt{0x116e}]$",loosely dotted] 0x13dd ->["$\stack=[\mathtt{0x116e}]$",dashed] t2/0x116e[good]
      }
    };
  \end{tikzpicture}
  \caption{Throwing an exception.}\label{fig:example-unwinding}
\end{figure}
% It's annoying but I have to compress the assembly all the way if I want to include the annotations
\begin{lstlisting}[
  %    float,
  style=x64,
  gobble=4,
  multicols=2, % apparently you sometimes have to include the multicol package explicitly?
  basicstyle=\scriptsize\ttfamily, % needed to fit things in more compactly with multicols in LNCS format!
  caption=Example throw.,
  label=lst:example-throw
  ]
  125b:call 10d0 <__cxa_allocate_exception|\label{lst:example-allocate}|
  1260:mov rbx,rax |\label{lst:example-throw-move}|
  1263:lea rsi,[rip+0xd9b] # 2005
  126a:mov rdi,rbx
  126d:call 10e0#std::domain_error init |\label{lst:example-initialize}|
  1272:mov rax,QWORD PTR [rip+0x2d4f] |\label{lst:example-global-read}|
  1279:mov rdx,rax
  127c:lea rsi,[rip+0x2abd] # 3d40
  1283:mov rdi,rbx
  1286:call 1120 <__cxa_throw |\label{lst:example-throw-call}|
  ...
  129c:call 10f0 <__cxa_free_exception |\label{lst:example-free}|
\end{lstlisting}
Some of the additional information provided by \iac{eicfg} is illustrated in \cref{fig:example-unwinding},
which models the process of throwing an exception from the same example program as \cref{fig:ghidra-example}.
The representation in the figure indicates the process of unwinding from one throw site in the control flow graph to a try-catch block or cleanup landing pad.
This path was triggered by the snippet of assembly shown in \cref{lst:example-throw}, which allocates (\instref{lst:example-allocate}{125b}), initializes (\instref{lst:example-initialize}{126d}), and throws (\instref{lst:example-throw-call}{1286}) an exception.
The landing pad table of the binary, $\landingpadtable$, directs the unwinding process:
when stack unwinding reaches address~$i$ and $j\in\landingpadtable(i)$,
control flow branches to address~$j$.
Otherwise, another frame is popped off the stack.
This will be elaborated on in
%\cref{sec:landing-pad-table}.
\cref{sec:abstract-state}.
For this example, we get unwinding from address (\instref{lst:example-throw-call}{1286}) to
%\instref{lst:unwind-site}{137e}
\inlineasm{0x137e}
to \instref{lst:landing-pad}{138b}.

Due to overapproximation, there are two possible paths from that point.
One is the path for an exception object that is not of the caught type,
some checks of which occur via the assembly instructions \instref{lst:assembly-type-check}{138f} and \instref{lst:assembly-type-jump}{1393} of \cref{lst:example-throw-landing-pad}.
This path results in unwinding being resumed (\instref{lst:unwind-resume}{1398}) and leads to a bad termination case at instruction \instref{lst:example-hlt}{116e}.
The other path continues from node \instref{lst:matching-catch-target}{139d}.
It eventually leads to \instref{lst:example-hlt}{116e} from \instref{lst:example-ret}{13dd} (intervening nodes elided).
This is a good termination case as reaching that halting instruction occurred outside unwinding.

\begin{figure}
  \centering
  \begin{tikzpicture}[every node/.style={node font=\ttfamily}]
    \graph[grow down=.9cm,branch right=4cm,nodes=draw]{
      0x135f -> {
        a1/"[0x1362,0x137a]"[>"$j=0$"'] ->["$j=0$"'] a2/0x137c ->["\inlineasm{call tbl[0]}"', dashed] "[0x12b5,0x12cb]",
        b1/"[0x1362,0x137a]"[>"$j=1$"] ->["$j=1$"] b2/0x137c ->["\inlineasm{call tbl[1]}", dashed] "[0x1229,0x123f]"
      }
    };
  \end{tikzpicture}
  \caption{Identifying indirection.}\label{fig:example-indirect-call}
\end{figure}
Meanwhile, indirect function call resolution is shown in \cref{fig:example-indirect-call}, which is a representation of \cref{lst:example-indirect-call}.
This process occurs when we detect a value being read from a part of the state
that is positively bounded, because such values may be jump table indices.
In the given example, that bound is provided by a conditional check previously (instructions \instref{lst:example-cmp}{1359} and \instref{lst:example-conditional-jump}{135d} of \cref{lst:example-indirect-call}).
When this happens and the state part being read from does not already have a fixed value, we generate non-deterministic edges where the read value ranges from 0 to the upper bound.
This can be seen in the middle graph edges of \cref{fig:example-indirect-call},
which connect the same addresses but have different jump table indices.
In the compiled assembly of the program, the jump table index selection occurs at \instref{lst:example-jump-table-index}{135f}.
Such values can then be used later on in the calculation of jump table addresses, in this case by \instref{lst:example-jumptable-read}{136c} and \instref{lst:example-jumptable-calculate}{1373}.
This non-deterministically results in \instref{lst:example-indirect-call-call}{137c} going to different address ranges, as shown in the graph.

% replacing the tabs with spaces to try to compress things
\begin{lstlisting}[
  %    float,
  style=x64,
  gobble=4,
  multicols=2,
  basicstyle=\scriptsize\ttfamily, % needed to fit things in more compactly with multicols in LNCS format!
  caption=Example throw landing pad.,
  label=lst:example-throw-landing-pad
]
  1387: mov eax,ebx
  1389: jmp 13d7 <main+0x92>
  138b: endbr64 |\label{lst:landing-pad}|
  138f: cmp rdx,0x1 |\label{lst:assembly-type-check}|
  1393: je 139d <main+0x58> |\label{lst:assembly-type-jump}|
  1395: mov rdi,rax
  1398: call 1130 <_Unwind_Resume |\label{lst:unwind-resume}|
  139d: mov rdi,rax |\label{lst:matching-catch-target}|
  13a0: call 10c0 <__cxa_begin_catch |\label{lst:begin-catch}|
  13a5: mov QWORD PTR [rbp-0x18],rax
  13a9: cmp DWORD PTR [rbp-0x24],0x0
  13ad: jns 13b4 <main+0x6f>
  13af: call 1100 <__cxa_rethrow |\label{lst:assembly-rethrow}|
  13b4: mov ebx,0x0
  13b9: call 1110 <__cxa_end_catch |\label{lst:end-catch}|
  13be: jmp 1387 <main+0x42>
  13c0: endbr64
  ...
  13d7: add rsp,0x28
  13db: pop rbx
  13dc: pop rbp
  13dd: ret |\label{lst:example-ret}|
\end{lstlisting}
\begin{lstlisting}[
  %    float,
  style=x64,
  gobble=4,
  multicols=2,
  basicstyle=\scriptsize\ttfamily, % needed to fit things in more compactly with multicols in LNCS format!
  caption=Example indirect call.,
  label=lst:example-indirect-call
]
  1359: cmp DWORD PTR [rbp-0x24],0x1 |\label{lst:example-cmp}|
  135d: jg 1382 <main+0x3d> |\label{lst:example-conditional-jump}|
  135f: mov eax,DWORD PTR [rbp-0x24] |\label{lst:example-jump-table-index}|
  1362: cdqe
  1364: lea rdx,[rax*8+0x0]
  136c: lea rax,[rip+0x29ad] # 3d20 |\label{lst:example-jumptable-read}|
  1373: mov rdx,QWORD PTR [rdx+rax*1] |\label{lst:example-jumptable-calculate}|
  1377: mov eax,DWORD PTR [rbp-0x24]
  137a: mov edi,eax
  137c: call rdx |\label{lst:example-indirect-call-call}|
  137e: mov ebx,eax |\label{lst:unwind-site}|
\end{lstlisting}
\begin{lstlisting}[
  %    float,
  style=x64,
  gobble=4,
  multicols=2,
  basicstyle=\scriptsize\ttfamily, % needed to fit things in more compactly with multicols in LNCS format!
  caption=The \texttt{\_start} function,
  label=lst:example-start
]
  1140:endbr64 |\label{lst:start-first}|
  1144:xor ebp,ebp |\label{lst:example-clear-reg}|
  1146:mov r9,rdx |\label{lst:example-start-move}|
  1149:pop rsi
  114a:mov rdx,rsp
  114d:and rsp,0xfffffffffffffff0
  1151:push rax
  1152:push rsp
  1153:lea r8,[rip+0x2f6] # 1450
  115a:lea rcx,[rip+0x27f] # 13e0
  1161:lea rdi,[rip+0x1dd] # 1345<main>
  1168:call QWORD PTR [rip+0x2e6a]#3fd8|\label{lst:example-libc}|
  116e:hlt |\label{lst:example-hlt}|
\end{lstlisting}
% |\label{lst:good-termination}|
