\chapter{Control-Flow-Driven Verification}

\section{Introduction}\label{se:cfg_intro}
The memory usage analysis approach presented in this section features a Floyd-style methodology.

This approach focuses on the property of \emph{memory preservation}.
See \cref{se:memory_preservation} for more information.

It features automatically-selected cutpoints.

% TODO: double-check, most stack frame stuff might be generated and it's just loop ones and a few others that aren't (recursion too)
Some basic invariants are generated but most must be added manually.

Recursion is supported but requires a significant amount of work,
much greater than that needed for loops and function calls alone.

% TODO: revise this?
The methodology was applied to several example functions
as well as functions from the HermitCore unikernel library.
Documentation of the example functions can be found in \cref{se:cfg_examples}.
The HermitCore function work can be found in \cref{se:cfg_applications}.

% TODO: maybe move into Memory Usage section
\section{Memory Preservation}\label{se:memory_preservation}
Memory preservation shows that the values written by a program
are restrained to specified regions in memory.
This property is useful for several reasons.

\subsubsection{Security}
Unbounded memory usage can lead to vulnerabilities
such as buffer overflows and data leakage.
One example of such a vulnerability would be 2014's Heartbleed~\citep{heartbleed}.
Heartbleed was caused by a lack of bounds checking on a string array
requested as output as part of a ``heartbeat'' message.
This, combined with a custom memory manager
that also had no security protections against out-of-bounds memory accesses,
lead to potential leakage of sensitive data such as passwords and encryption keys.

\subsubsection{Composition}
\subsubsection{Concurrency}

\section{Floyd Invariant Foundation}\label{se:cfg_invariant}
% TODO: more here?

Loops pose a significant problem when using symbolic execution to analyze code.

Breaking up symbolic execution of loops is one method of resolving those issues.

By using a control-flow-based Floyd approach, we can easily achieve this.

Taking this approach also allows minimizing symbolic execution
even in non-loop situations.
Placing a cutpoint at the start of each block where control flow converges
results in all instructions being symbolically executed only once each.

% TODO: need more

\section{Composition}
Composition is crucial for scalability.

This control-flow-oriented approach provides compositionality
on the level of function calls.

%TODO: figure out if Hoare triples actually used for composition here.

\section{Verification}\label{se:cfg_verification}

\section{Examples}\label{se:cfg_examples}
\subsection{Non-recursive example}

\subsection{Recursion: Factorial}
The factorial operation can provide a simple example of recursion.
The basic definition of factorial is $n!=\prod_{i=1}^n i$.%
\nomenclature{$\prod$}{Product of a sequence of terms; multiplication equivalent of $\sum$.}
This results in a number that is the product of the numbers from $1$ to $n$.
Expressed in recursive form, that definition is:
\begin{equation}
  n!=\begin{cases}
    n * (n - 1)! & \text{if }n > 0 \\
    1 & \text{if }n = 0
  \end{cases}
\end{equation}
This can be easily represented in a programming language. % TODO: kind of a pointless sentence, I feel.

\section{Applications}\label{se:cfg_applications}
% HermitCore
A \emph{unikernel} is a program designed for a specific task
that is compiled with all kernel code necessary to run the program,
bypassing the need for \iac{os}~\citep{madhavapeddy2014unikernels}.
Unikernels can be used with hypervisors or even on bare metal systems.
\Acp{os} do stuff.

\section{Limitations}
