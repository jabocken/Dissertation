\chapter{EICFG Formulation}\label{ch:eicfg-formulation}

The derivation of \acp{eicfg} from a binary requires four additional things:
\begin{enumerate}
    \item a static landing pad table,
    \item an abstract state model,
    \item an abstract transition relation, and
    \item a symbolic execution engine to apply the rules making up our abstract transition relation.
\end{enumerate}
We describe those here.

\section{Landing Pad Table}\label{sec:landing-pad-table}
This information describes how unwinding should proceed given the unwinding reaching specific locations in a binary.
It is extracted from the \acp{cie}, \acp{fde}, and \acp{lsda} of the binary under test and assumed to be correct.
In our current formulation, an entry in the catch table is merely a pointer to the corresponding landing pad for this entry.
While type pointers and exception specifications exist within the \acp{lsda} as well, we do not currently utilize that information.
% I did try to get things working but the implementation was buggy in some edge cases and properly doing type matching requires some other work.
% Plus there's a combination with the typeinfo indices that needs work.

Thrown exceptions in \Cpp\ can be caught by catch blocks.
Individual stack frames may require cleanup during the process of unwinding as well.
The addresses of those catch blocks and cleanup routines are called landing pads.
To accomplish reaching those addresses during unwinding, we require a \emph{landing pad table}.

\begin{definition}
  A landing pad table~$\landingpadtable$ is a static map from instruction address to set of possible landing pads.
  Formally, with~$\pointer$ as the type of addresses,~$\landingpadtable$s have type $\pointer\to2^\pointer$.
\end{definition}
Currently, we overapproximate and do not include exception type when determining landing pads.
The keys of the table are the ranges of addresses to which the corresponding landing pad entry applies, intervals that are open in the lower bound but closed in the upper bound. This interval layout was chosen to support \inlineasm{rip} being incremented at the start of instruction evaluation. It is traditionally represented in the form $(a,b]$, where~$a$ is the lower bound of the interval and~$b$ is the upper bound.
\begin{example}\label{ex:landing-pad-table}
  One of our running example landing pad entries is  $\landingpadtable(\mathtt{0x137e})=\{\mathtt{0x138b}\}$.
  Thus, when an unwinding routine reaches instruction \inlineasm{0x137e}, % \instref{lst:unwind-site}{137e} of \cref{lst:example-indirect-call},
  that routine will jump to \instref{lst:landing-pad}{138b}.
\end{example}

\section{Abstract State}\label{sec:abstract-state}
Our exception-containing abstract states, type $\absState$, are records with named fields.
In defining this record type, the following elemental types are used, some of which are new:
\begin{itemize} % Freek didn't like the inlining with labels and it looks bad without them so just turning into plain list when space is needed
  \item $\bool$ and $\nat$ denote Booleans and natural numbers respectively;
  \item $\val$,
  which may be~$\bot$, indicating any or an unknown or undefined value;
  \item $\pointer$ denotes \emph{immediate 64-bit addresses};
  \item $\word$ denotes \emph{exception IDs}; and
  \item $\termination$ denotes \emph{program termination}, consisting of the set $\{\bot,\good,\bad\}$.
\end{itemize}
%$\bool$ and $\nat$ denote Booleans and natural numbers respectively;
%$\val$ denotes \emph{symbolic expressions}, which may be~$\bot$, indicating any or an unknown or undefined value;
%$\pointer$ denotes \emph{immediate 64-bit addresses};
%$\word$ denotes \emph{exception IDs}; and
%program termination type $\termination\coloneqq\{\bot,\good,\bad\}$.

\subsection{Exception Objects}
\begin{definition}
  Exceptions are also records, having type
%  $\exception\coloneqq\{\rethrown\colon\bool,\handlerCount\colon\natnum\}$.
  \begin{equation*}
    \exception\coloneqq\begin{cases}
      \rethrown &\colon \bool \\
      \handlerCount &\colon \nat
    \end{cases}
  \end{equation*}
  This record has two fields.
  Boolean field $\rethrown$ indicates rethrown status of the exception.
  Natural field $\handlerCount$ stores the current count of catch block handlers for the exception.
  % extra field: stores the $\mathsf{size}$ of its payload as a 64-bit unsigned integer. % not used here as we don't track the payload anyway.
\end{definition}
$\absState$, meanwhile, has the following fields:

\subsection{Registers}
%\subsection{$\rmap$: the register map}
The field~$\rmap$ has type $\register\to\val$.
Reading and writing registers smaller than 64 bits (e.g.\ \inlineasm{ebp} versus \inlineasm{rbp}) requires bit masking and shifting the underlying 64-bit register's value.
This behavior is integrated into our symbolic execution engine.
Larger registers (e.g.\ \inlineasm{xmm}%and other vector registers
) exist as operands in our instruction representation but are not used for state updates or reads.

\subsection{Call Stack}
%\subsection{$\stack$: the return address stack.}
%Maintaining the current list of return addresses is necessary in order to perform stack unwinding and handle thrown exceptions.
%It is also helpful in detecting recursion.
%With $[X]$ representing a list of type~$X$
This field has list type $[\pointer]$.
The following functions perform standard push/pop/peek stack operations on such lists:
\(
\push\colon X\times[X]\to[X],
\pop\colon[X]\to[X],
\peek\colon[X]\to X
\).
% \begin{align*}
  %     \push &\colon X\times[X]\to[X] \\
  %     \pop &\colon [X]\to[X] \\
  %     \peek &\colon [X]\to X
  % \end{align*}
For our purposes, usage of $\peek$ assumes a non-empty list. % would prefer this outside the definition but trying to save space
\begin{example}
  \Cref{lst:example-start} illustrates the entry point to our example program.
  For the initial state, we have an empty stack:~$[]$.
  The call at \instref{lst:example-libc}{1168} pushes the return address to the stack.
  Thus, after execution of the call, we have a stack $[\mathtt{0x116e}]$.
  %
  %below hidden to reduce space.
  Instruction \instref{lst:example-libc}{1168} of that \namecref{lst:example-start} calls \inlineasm{__libc_start_main}.
  We model that call simply as a call to the function pointer in the \inlineasm{rdi} register, the program's \inlineasm{main} function.
  For our purposes, that means pushing the instruction following the call onto the stack as a return address.
  Thus, for some state after the result of transitioning from \instref{lst:example-libc}{1168}, the stack is $[\mathtt{0x116e}]$.
\end{example}

\subsection{$\emap$: the exception mapping.}
This field has type $\word\to\exception$.
When an exception is created, it receives an ID based on its creation location and is stored in $\emap$ with that ID as the key.

% Freek wanted this before the auxiliary exception variables so reflecting that in the final record type as well.
\subsection{$\terminated$: the termination state.}
This field has type $\termination$.
It defaults to the bottom value~$\bot$, indicating the program or function has not terminated yet.
When a path of execution completes, it is set to either $\good$ or $\bad$, indicating either normal or abnormal termination, respectively.
We treat cases where an exception propagates to the top of the stack without being caught to be such ``bad'' cases.

\subsection{Auxiliary Exception Variables}
$\absState$ also contains a count of the number of currently-uncaught exceptions ($\uncaught\colon\nat$) and a stack of the currently-caught exception IDs ($\caught\colon[\word]$).
These fields are manipulated and used during entry to and exit from catch blocks as well as when rethrowing exceptions.
This handling comes into play when dealing with nested catch blocks, exceptions (re)thrown within such blocks, etc.

%\subsection{The abstract state record restated:} % Freek didn't like this so leaving out
\begin{definition}
  The type of abstract states, notation~$\absState$, is a record
%  \(
%  %        \absState\coloneqq
%  \{
%  \rmap\colon\register\to\val,
%  \stack\colon[\pointer],
%  \emap\colon\word\to\exception,
%  \terminated\colon T,
%  \uncaught\colon\nat,
%  \caught\colon[\word]
%  \}
%  \).
  \begin{equation*}
    \absState\coloneqq\begin{cases}
      \rmap &\colon \register\to\val \\
      \stack &\colon [\pointer] \\
      \emap &\colon \word\to\exception \\
      \terminated &\colon T \\
      \uncaught &\colon \nat \\
      \caught &\colon [\word]
    \end{cases}
  \end{equation*}
  To ease register references, for some state $\sigma$ and named register \texttt{r}, the notation $\sigma.\mathtt{r}$ is shorthand for $\sigma.\rmap(\mathtt{r})$, e.g.\ $\sigma.\rdi\equiv\sigma.\rmap(\rdi)$. % would prefer this outside the definition but trying to save space
\end{definition}

\section{Abstract Transition Rules}\label{sec:step-function}
To go along with our definition of \acp{eicfg} in \cref{def:eicfg},
we have defined our abstract transition relation in terms of logical rules.
There are two sets of those rules.

The first set of rules defines behavior for the instructions from the x86-64 \ac{isa}.
This includes non-deterministic conditional jump handling as well as handling for unknown external functions and a subset of indirect jumps and calls.
Those rules and the additional state parts required to model them are elided here.
The exception is how we deal with recursion, as that can be explained informally using elements already in $\absState$.
Assume a call to another function inside the binary for some state~$\sigma$. Then, if the return address to be pushed on the stack is already in $\sigma.\stack$, we instead treat that call as an unmodeled external call and continue execution past it.

The second set of rules provides modeling for exception-related \ac{abi} calls.
This set of rules is documented in \cref{fig:unwind,fig:step-rules1,fig:step-rules2} and elaborated on below.
The following abbreviations are utilized in those rules.
We also have notation for incrementing and decrementing: % moved up to save space
$\handler(\id,\sigma')\inc$ indicates $\handler(\id,\sigma')=\handler(\id,\sigma)+1$.
For certain rules, we also have $\handler(\id,\sigma')\inc*$, indicating $\handler(\id,\sigma')=\abs{\handler(\id,\sigma)}+1$,
and $\handler(\id,\sigma')\dec*$, indicating $\handler(\id,\sigma')=-\operatorname{sign}(\handler(\id,\sigma))*(\abs{\handler(\id,\sigma)}-1)$.
As a special case, $0\dec*=0$.
%$\dec$ follows the same concept.
%\begin{align*}
%  \handler(\id,\sigma) &\equiv \sigma.\emap(\id).\handlerCount &
%  \reth(\id,\sigma) &\equiv \sigma.\emap(\id).\rethrown \\
%  \pushStack(\mathit{fr},\sigma,\sigma') &\equiv \sigma'.\stack=\push(\mathit{fr},\sigma.\stack) &
%  \popStack(\sigma,\sigma') &\equiv \sigma'.\stack=\pop(\sigma.\stack) \\
%  \pushCaught(c,\sigma,\sigma') &\equiv \sigma'.\caught=\push(c,\sigma.\caught) &
%  \popCaught(\sigma,\sigma') &\equiv \sigma'.\caught=\pop(\sigma.\caught)
%\end{align*}
 \begin{align*}
 %    \mathsf{scratch} &\equiv \{\rax,\rdi,\rsi,\reg{rdx},\reg{rcx},\reg{r8},\reg{r9},\reg{r10},\reg{r11}\}\\
 %    \csr(\sigma,\sigma') &\equiv \forall r\not\in\mathsf{scratch}\quad\sigma.r=\sigma'.r\\
  \handler(\id,\sigma) &\equiv \sigma.\emap(\id).\handlerCount \\
  \reth(\id,\sigma) &\equiv \sigma.\emap(\id).\rethrown \\
  \pushStack(\mathit{fr},\sigma,\sigma') &\equiv \sigma'.\stack=\push(\mathit{fr},\sigma.\stack) \\
  \popStack(\sigma,\sigma') &\equiv \sigma'.\stack=\pop(\sigma.\stack) \\
  \pushCaught(c,\sigma,\sigma') &\equiv \sigma'.\caught=\push(c,\sigma.\caught) \\
  \popCaught(\sigma,\sigma') &\equiv \sigma'.\caught=\pop(\sigma.\caught)
\end{align*}

\begin{figure*}
  \centering
  \subfloat[Recursive unwinding]{%
    % \AxiomC{$\sigma'.\rip=\peek(\sigma.\stack)$}
    % \AxiomC{$\popStack(\sigma,\sigma')$}
    \AxiomC{\begin{array}[b]{l}
        \sigma'.\rip=\peek(\sigma.\stack) \\
        \popStack(\sigma,\sigma')
    \end{array}}
    \AxiomC{$\sigma'\unwindTransition\sigma''$}
    \BinaryInfC{$\sigma\unwindTransition\sigma''$}
    \DisplayProof\label{fig:unwind1}% prooftree env doesn't work in subfloat
  }\hfill
  \subfloat[Landing pad found]{%
    \AxiomC{$\sigma'.\rip\in\landingpadtable(\sigma.\rip)$}
    \UnaryInfC{$\sigma\unwindTransition\sigma'$}
    \DisplayProof\label{fig:unwind_lpt_found}% prooftree env doesn't work in subfloat
  }\hfill
  \subfloat[No landing pad]{%
    \AxiomC{$\sigma.\stack=[]$}
    \UnaryInfC{$\sigma\unwindTransition\sigma$}
    \hspace{1.9ex}
    \DisplayProof\label{fig:unwind_no_lpt_found}% prooftree env doesn't work in subfloat
    \hspace{1.9ex}
  }
  \caption{Unwinding.}
  \label{fig:unwind}
\end{figure*}

The transition rules are placed into two groups.
Group one, in \cref{fig:step-rules1}, does not involve unwinding.
The second, in \cref{fig:step-rules2}, does.

\subsection{Non-Unwinding Rules}
\Cref{fig:start-main} shows the rule for the special starting function \inlineasm{__libc_start_main}.
For this rule, we require the post-state's current instruction pointer be restricted to whatever was previously stored in \inlineasm{rdi}, \inlineasm{rcx}, or \inlineasm{r8}.
We also require the stored return address to be on the top of a newly-pushed stack frame.

\begin{example}
  After the call to \inlineasm{__libc_start_main} that is instruction \instref{lst:example-libc}{1168} of \cref{lst:example-start},
  we will have $\sigma'.\rip\in\{\mathtt{0x1345},\mathtt{0x13e0},\mathtt{0x1450}\}$ and $\sigma'.\stack=[0x116e]$.
\end{example}
Next, \cref{fig:allocate-exception} illustrates the rule for \inlineasm{__cxa_allocate_exception}.
Our modeling assumes a system where virtual memory allocations always succeed (and the runtime terminates programs when they use up too much memory).
It results in an exception object added to the exception map with the post-state $\sigma'$'s instruction pointer as its ID.
The object starts in a non-rethrown state and with no handlers.
The ID is also set as the return value of the function in $\sigma'.\rax$.

\begin{example}
  After instruction \instref{lst:example-allocate}{125b} of \cref{lst:example-throw},
  we have:
  \begin{gather*}
    \sigma'.\rax=\mathtt{0x1260} \\
    \sigma'.\emap(\mathtt{0x1260}).\handlerCount=0 \\
    \neg\sigma'.\emap(\mathtt{0x1260}).\rethrown.
  \end{gather*}
\end{example}
The rule in \cref{fig:free-exception} is for function \inlineasm{__cxa_free_exception}.
This rule ensures the absence of an exception in the exception map based on the given ID.
At our level of abstraction, \inlineasm{_Unwind_DeleteException} exhibits the same semantics and is thus elided.

\begin{example}
  Consider instruction \instref{lst:example-free}{129c} of \cref{lst:example-throw}.
  The result of this instruction is $\sigma'.\emap=\varnothing$.
\end{example}
The rules in \cref{fig:begin-catch1,fig:begin-catch2} define \inlineasm{__cxa_begin_catch} behavior for different cases.
For an exception not already caught, the associated rule pushes it onto the caught-exception stack.
The rule for already-caught exceptions does not do this.
However, both rules increment that exception's handler count and decrement the state's count of uncaught exceptions.
Though not listed, there is also a rule for an ID not currently in the exception map.
That rule operates the same as our (elided) rule for unmodeled external calls.
This allows for safe overapproximation.

\begin{example}\label{ex:begin-catch}
  Consider instruction \instref{lst:begin-catch}{13a0} of \cref{lst:example-throw-landing-pad}.
  Assuming the existence of a valid exception object with ID~$\id$ that was just thrown, the post-state~$\sigma'$ will satisfy $\handler(\id,\sigma')=1$, $\sigma'.\caught=[\id]$, and $\sigma'.\uncaught=0$.
\end{example}
To complete the above, the rules in \cref{fig:end-catch1,fig:end-catch2} define some \inlineasm{__cxa_end_catch} behavior.
The first rule applies when an exception ID is available on top of the caught stack, there are no more handlers for the corresponding exception object,
and it is being rethrown.
In this case, it is popped off the caught stack and no longer treated as being rethrown.
The second rule applies when an exception is available, has no more handlers, and is not being rethrown. In that case, it is popped off the caught stack and removed from the exception map.
Not shown is the rule for an exception that still has handlers remaining.
In that case, its handler count is decremented but no other changes are made.
Additionally, the case for an empty $\sigma.\caught$ again operates as an unmodeled external call for the sake of overapproximation.
\begin{example}
  Consider instruction \instref{lst:end-catch}{13b9} of \cref{lst:example-throw-landing-pad}.
  Assume the statements in \cref{ex:begin-catch} hold for the pre-state.
  %    Assume the statements for catch beginning hold for the pre-state.
  Then, the post-state~$\sigma'$ for that instruction will satisfy $\sigma'.\emap(\id)=\bot$ and $\sigma'.\caught=[]$.
\end{example}
\subsection{Unwinding Rules}
\Cref{fig:unwind} shows semantics for stack unwinding.
The stack is recursively popped (\cref{fig:unwind1}) until one of two conditions occurs: a landing path is found (\cref{fig:unwind_lpt_found}) or not (\cref{fig:unwind_no_lpt_found}).
For shorthand notation, we respectively use $\unwindTransitionyes$ and $\unwindTransitionno$ to indicate the compound stack unwinding transition from a state until one of those conditions is met.

%The first transition rule is one for unwinding.
%This rule, shown in \cref{fig:unwind}, uses special notation for the transition, $\unwindTransition$ instead of $\absTransition$.

% TEXT FOR EXAMPLE IS GOOD, BUT PRUNED FOR SPACE CONSTRAINTS
%\begin{example}
%    Assume $\sigma.\stack=[\mathtt{0x116e}]$. Then, for $\sigma\unwindTransition\sigma'$ to hold, we must have %$\sigma'.\stack=\varnothing$ and $\sigma'.\rip=\mathtt{0x116e}$.
%\end{example}

%The rules featuring stack unwinding utilize repeated application of $\unwindTransition$ until a predicate is satisfied.
%In essence, they feature an \emph{until} loop.
%This loop terminates in one of two ways.
%One, a set of landing pads is found at some point in the process.
%Two, the stack is completely unwound with no landing pads found.
%The former case carries through the thrown exception object ID from its function argument register to the %``result'' register $\rax$. % have this repeated below
%The latter case results in a bad termination.

\Cref{fig:unwind-resume1,fig:unwind-resume2} show the simplest unwinding function rules, those for \inlineasm{_Unwind_Resume}.
The main addition to the general unwinding transition is that, when landing pads are found, the original function argument ($\sigma.\rdi$) is preserved in the result state's return register ($\sigma'.\rax$).
This models the concrete handling for carrying through exceptions during unwinding.

\begin{example}
  Consider instruction \instref{lst:unwind-resume}{1398} of \cref{lst:example-throw-landing-pad}.
  %As previously described in \cref{sec:example},
  As previously described in \cref{sec:eicfg},
  this instruction is intended to continue unwinding for exceptions that do not satisfy the source code's catch type specification.
  Assuming no more applicable landing pad table entries, the only valid post-states for the transition here match $\sigma'.\stack=[]$ and $\sigma'.\terminated=\bad$.
\end{example}
The rules for the initiating function \inlineasm{__cxa_throw}, shown in \cref{fig:throw1,fig:throw2}, expand on those for \inlineasm{_Unwind_Resume}.
They add the condition that the post-state's uncaught exception count is incremented. At our level of abstraction, the function \inlineasm{_Unwind_RaiseException} is semantically equivalent to \inlineasm{__cxa_throw} and thus shares its rules.

\begin{example}
  Consider instruction \instref{lst:example-throw-call}{1286} of \cref{lst:example-throw}.
  We previously stepped through the process of throwing using this instruction in
  %    \cref{sec:example},
  \cref{sec:eicfg},
  so we merely state the results here.
  As this is the first throw at this time, we have $\sigma'.\uncaught=1$.
  Additionally, the unwinding process stops for $\sigma'.\rip\in\landingpadtable(\mathtt{0x137e})=\{\mathtt{0x138b}\}$, giving us $\sigma'.\rip=\mathtt{0x138b}$.
\end{example}
The rules for \inlineasm{__cxa_rethrow} in \cref{fig:rethrow1,fig:rethrow2} add a twist by utilizing the current caught-exception stack.
When an exception object ID is available on the top of the caught stack,
unwinding proceeds as usual.
Futhermore, the corresponding exception object is marked as being rethrown and its ID is stored in $\rax$ for later usage.
By contrast, when no caught exception objects are available, \inlineasm{__cxa_rethrow} must lead to an abnormal termination for strict modeling.
However, that second rule can be relaxed for additional overapproximation by using the \inlineasm{_Unwind_Resume} rules instead.

\begin{example}
  Consider instruction \instref{lst:assembly-rethrow}{13af} of \cref{lst:example-throw-landing-pad}.
  Assume caught stack $\sigma.\caught=[\id]$, $\sigma.\emap(\id)=e$, and $\landingpadtable(\mathtt{0x13af})=\{\mathtt{0x13c0}\}$.
  Then we end up with $\sigma'.\rip=\mathtt{0x13c0}$ and $\sigma'.\emap(\id).\rethrown$.
\end{example}

%\newcommand\clearScratchClause{\AxiomC{$\csr(\sigma,\sigma')$}}
\begin{figure*}
  \centering
  \subfloat[\inlineasm{__libc_start_main}]{%
    % \AxiomC{$\sigma'.\rip=\sigma.\rdi$}
    % \AxiomC{$\pushStack(\sigma.\rip+5,\sigma,\sigma')$}
    \AxiomC{$\begin{array}[b]{l}
        \sigma'.\rip\in\sigma.\{\rdi,\rcx,\reg{r8}\} \\
        \pushStack(\sigma.\rip+5,\sigma,\sigma')
      \end{array}$}
    \UnaryInfC{$\sigma\absTransition\sigma'$}
    %        \hspace{1ex}
    \DisplayProof\label{fig:start-main}% prooftree env doesn't work in subfloat
    %        \hspace{1ex}
  }
  \subfloat[\inlineasm{__cxa_allocate_exception}]{%
    %        \AxiomC{$\id=\sigma'.\rip$}
    \AxiomC{$\begin{array}[b]{l}
        \id=\sigma'.\rip \\
        \sigma'.\rax=\id % would have preferred this on the other side but I need all the space I can get.
      \end{array}$}
    \AxiomC{$\begin{array}[b]{l}
        %            \sigma'.\rax=\id \\
        \sigma'.\emap(\id)=e \\
        %            e.\mathsf{size} = \sigma.\rdi
        \neg e.\rethrown \\
        e.\handlerCount=0
      \end{array}$}
    \BinaryInfC{$\sigma\absTransition\sigma'$}
    \DisplayProof\label{fig:allocate-exception}%
  }
  \subfloat[\inlineasm{__cxa_free_}\\
  \inlineasm{exception}]{%
    % \AxiomC{$\id=\sigma.\rdi$}
    % \AxiomC{$\sigma'.\emap(\id)=\bot$}
    \AxiomC{$\sigma'.\emap(\sigma.\rdi)=\bot$}
    \UnaryInfC{$\sigma \absTransition \sigma'$}
    \DisplayProof\label{fig:free-exception}%
  }\\
  \subfloat[\inlineasm{__cxa_begin_catch} (not already cght)]{%
    \AxiomC{$\begin{array}[b]{l}
        \id=\sigma.\rdi \\
        \id\not\in\sigma.\caught
      \end{array}$}
    % \AxiomC{$\id\not\in\sigma.\caught$}
    \AxiomC{$\begin{array}[b]{l}
        \handler(\id,\sigma')\inc* \\
        \pushCaught(\id,\sigma,\sigma') \\
        \sigma'.\uncaught\dec
      \end{array}$}
    % \AxiomC{$\handler(\id,\sigma')\inc*$}
    % \AxiomC{$\pushCaught(\id,\sigma,\sigma')$}
    % \AxiomC{$\sigma'.\uncaught\dec$}
    % \RightLabel{$\id=\sigma.\rdi$}
    \BinaryInfC{$\sigma\absTransition\sigma'$}
    \hspace{2ex}
    \DisplayProof\label{fig:begin-catch1}%
    \hspace{2ex}
  }\hfill
  \subfloat[\inlineasm{__cxa_begin_catch} (already caught)]{%
    \AxiomC{$\begin{array}[b]{l}
        \id=\sigma.\rdi \\
        \id\in\sigma.\caught
      \end{array}$}
    % \AxiomC{$\id\in\sigma.\caught$}
    \AxiomC{$\begin{array}[b]{l}
        \handler(\id,\sigma')\inc* \\
        \sigma'.\uncaught\dec
      \end{array}$}
    % \AxiomC{$\handler(\id,\sigma')\inc*$}
    % \AxiomC{$\sigma'.\uncaught\dec$}
    % \RightLabel{$\id=\sigma.\rdi$}
    \BinaryInfC{$\sigma\absTransition\sigma'$}
    \hspace{1.7ex}
    \DisplayProof\label{fig:begin-catch2}%
    \hspace{1.7ex}
  }\\
  \subfloat[\inlineasm{__cxa_end_catch} (cghts, last hndl, rt)]{%
    \AxiomC{$\begin{array}[b]{l}
        \id=\peek(\sigma.\caught) \\
        %            \sigma.\caught\neq[]\\
        \handler(\id,\sigma)=1\\
        \reth(\id,\sigma)
      \end{array}$}
    \AxiomC{$\begin{array}[b]{l}
        \handler(\id,\sigma')=1 \\
        \neg\reth(\id,\sigma') \\
        \popCaught(\sigma,\sigma') \\
      \end{array}$}
    %        \AxiomC{$\handler(\id,\sigma')=1$}
    %        \AxiomC{$\neg\reth(\id,\sigma')$}
    %        \AxiomC{$\popCaught(\sigma,\sigma')$}
    %        \RightLabel{$\id=\peek(\sigma.\caught)$}
    \BinaryInfC{$\sigma\absTransition\sigma'$}
    \DisplayProof\label{fig:end-catch1}%
  }\hfill
  \subfloat[\inlineasm{__cxa_end_catch} (\dots, not rethrown)]{%
    \AxiomC{$\begin{array}[b]{l}
        \id=\peek(\sigma.\caught) \\
        \handler(\id,\sigma)=1\\
        \neg\reth(\id,\sigma)
      \end{array}$}
    \AxiomC{$\begin{array}[b]{l}
        \handler(\id,\sigma')=1 \\
        \sigma'.\emap(\id)=\bot \\
        \popCaught(\sigma,\sigma')
      \end{array}$}
    %        \AxiomC{$\handler(\id,\sigma')=1$}
    %        \AxiomC{$\sigma'.\emap(\id)=\bot$}
    %        \AxiomC{$\popCaught(\sigma,\sigma')$}
    %        \RightLabel{$\id=\peek(\sigma.\caught)$}
    \BinaryInfC{$\sigma\absTransition\sigma'$}
    \DisplayProof\label{fig:end-catch2}%
  }%
  \caption{Non-unwinding abstract step rules (unchanged state parts mostly elided).}
  \label{fig:step-rules1}
\end{figure*}

\begin{figure*}
  \centering
  \subfloat[\inlineasm{_Unwind_Resume} (LP(s))]{%
    %        \AxiomC{$\sigma\unwindTransitionyes\sigma'$}
    %        \AxiomC{$\sigma'.\rax=\sigma.\rdi$}
    \AxiomC{$\begin{array}[b]{l}
        \sigma\unwindTransitionyes\sigma' \\
        \sigma'.\rax=\sigma.\rdi
      \end{array}$}
    \UnaryInfC{$\sigma\absTransition\sigma'$}
    \hspace{4ex}
    \DisplayProof\label{fig:unwind-resume1}%
    \hspace{4ex}
  }\hfill
  \subfloat[\inlineasm{_Unwind_Resume} (no LPs)]{%
    %        \AxiomC{$\sigma\unwindTransitionno\sigma'$}
    %        \AxiomC{$\sigma'.\terminated=\bad$}
    \AxiomC{$\begin{array}[b]{l}
        \sigma\unwindTransitionno\sigma' \\
        \sigma'.\terminated=\bad
      \end{array}$}
    \UnaryInfC{$\sigma\absTransition\sigma'$}
    \hspace{5ex}
    \DisplayProof\label{fig:unwind-resume2}%
    \hspace{5ex}
  }\hfill
  \subfloat[\inlineasm{__cxa_throw} (LP(s))]{%. % \inlineasm{_Unwind_RaiseException}
    % \AxiomC{$\sigma\unwindTransitionyes\sigma'$}
    % \AxiomC{$\sigma'.\uncaught\inc$}
    % \AxiomC{$\sigma'.\rax=\sigma.\rdi$}
    \AxiomC{$\begin{array}[b]{l}
        \sigma\unwindTransitionyes\sigma' \\
        \sigma'.\uncaught\inc \\
        \sigma'.\rax=\sigma.\rdi
      \end{array}$}
    \UnaryInfC{$\sigma\absTransition\sigma'$}
    \hspace{2ex}
    \DisplayProof\label{fig:throw1}%
    \hspace{2ex}
  }\\
  \subfloat[\inlineasm{__cxa_throw} (no LPs)]{%. % \inlineasm{_Unwind_RaiseException}
    % \AxiomC{$\sigma\unwindTransitionno\sigma'$}
    % \AxiomC{$\sigma'.\terminated=\bad$}
    \AxiomC{$\begin{array}[b]{l}
        \sigma\unwindTransitionno\sigma' \\
        \sigma'.\terminated=\bad
      \end{array}$}
    \UnaryInfC{$\sigma\absTransition\sigma'$}
    \hspace{3ex}
    \DisplayProof\label{fig:throw2}%
    \hspace{3ex}
  }
  \subfloat[\inlineasm{__cxa_rethrow} (caught+LP(s))]{%
    % \AxiomC{$\sigma.\caught\neq[]$}
    % \AxiomC{$\sigma\unwindTransitionyes\sigma'$}
    % \AxiomC{$\reth(\id,\sigma')$}
    % \AxiomC{$\sigma'.\rax=\id$}
    % \AxiomC{$\sigma'.\uncaught\inc$}
    % \AxiomC{$\handler(\id,\sigma')\dec*$}
    \AxiomC{$\begin{array}[b]{l}
        %            \sigma.\caught\neq[] \\
        \sigma\unwindTransitionyes\sigma' \\
        \id=\peek(\sigma.\caught)
      \end{array}$}
    \AxiomC{$\begin{array}[b]{l}
        \sigma'.\uncaught\inc \\
        \handler(\id,\sigma')\dec* \\
        \reth(\id,\sigma') \\
        \sigma'.\rax=\id
      \end{array}$}
    %        \RightLabel{$\id=\peek(\sigma.\caught)$}
    \BinaryInfC{$\sigma\absTransition\sigma'$}
    \DisplayProof\label{fig:rethrow1}%
  }
  \subfloat[\inlineasm{__cxa_rethrow} alt]{%
    % \AxiomC{$\sigma.\caught=[]$}
    % \AxiomC{$\sigma'.\terminated=\bad$}
    \AxiomC{$\begin{array}[b]{l}
        \sigma.\caught=[] \\
        \sigma'.\terminated=\bad
      \end{array}$}
    \UnaryInfC{$\sigma\absTransition\sigma'$}
    \hspace{1ex}
    \DisplayProof\label{fig:rethrow2}%
    \hspace{1ex}
  }
  \caption{Abstract transition rules with unwinding (unchanged state parts are elided).}% At this level of abstraction, function \inlineasm{_Unwind_RaiseException} is semantically equivalent to \inlineasm{__cxa_throw}.}
\label{fig:step-rules2}
\end{figure*}

Additional rules exist for the process of \emph{forced unwinding}, or manual stack unwinding. Those are summarized here.
\inlineasm{_Unwind_ForcedUnwind} functions similarly to \inlineasm{__cxa_throw} (\cref{fig:throw1,fig:throw2}). However, instead of stopping based on landing pad table information, it executes the function stored in $\sigma.\rsi$ in each frame and uses the result to determine when to stop.
\inlineasm{_Unwind_DeleteException} functions like \inlineasm{cxa_free_exception} (\cref{fig:free-exception}) at the end of that process.
The helper function \inlineasm{_Unwind_GetIP} stores the current frame's instruction pointer in $\sigma'.\rax$.
Finally, the other helper function \inlineasm{_Unwind_GetRegionStart} stores the current procedure fragment's starting address in $\sigma'.\rax$.

\section{Symbolic Execution}
We perform symbolic execution by application of the rules making up our abstract transition relation.
For some initial abstract state $\sigma_0$, $\sigma_0.\rip$ is either manually provided or obtained from the binary's \ac{elf} info.
Then we iteratively fetch the instruction at that address, increment~$\rip$ appropriately, and apply the applicable abstract transition rule to obtain successor states.
If the transition rule results in multiple possible continuing states, we apply the symbolic execution step to each successor state.
If no non-terminating states result, this path of execution ends.

To prevent infinite loops and alleviate some of the state space issues that can occur with such non-deterministic evaluation, we provide a join operation.
This join operation is focused on exceptional state.
From $\absState$ it preserves $\emap$, $\uncaught$, and $\caught$. To maintain contextual awareness, it also preserves $\rip$, $\stack$, and $\terminated$.
As an implementation detail, it also includes the temporary indices used by our jump table heuristic to ensure proper separation.
All other state parts are combined, with priority given to the first equivalent state produced.
For a more aggressive join, $\emap$, $\uncaught$, and $\caught$ can be excluded from the preserved state parts. The abstract transition rules are also simplified to support this exclusion.

\todo{maybe describe this as an alternative in the Symbolic Execution chapter? Or tie this into the work from \cref{ch:lattice-lifting,ch:lattice-algorithm}.}

\section{Argument for Overapproximation}
%Formally, correctness of the produced \ac{eicfg} can be proven by showing that the abstract transition relation overapproximates the concrete one (see \cref{def:simulation}).
We consider a formal definition of the concrete transition rules our abstract ones overapproximate outside the scope of this paper.
This is because our abstraction focuses on the domain of exceptional control flow in terms of its \ac{abi}-level definition. By contrast, concrete rules require a concrete implementation.
Instead, we provide an informal argument for why our abstract transition rules are overapproximative.

First, for normal (non-exception-related) assembly instructions, our abstract transition rules default to assigning~$\bot$ to destination operands, overapproximating their effect.
Only those instructions whose arguments affect exception- and stack-related behavior as well as global memory operations receive full modeling.
They include \inlineasm{mov} and its relatives, \inlineasm{push}+\inlineasm{pop} and related instructions, and basic arithmetic/bitwise instructions.
If we did not model those instructions, we could lose too much information concerning exceptional or even regular control flow.

Second, for exception-related function calls, the semantics in \cref{fig:step-rules1,fig:step-rules2} purposefully omit information from the abstract state.
An example is the type of the exception being allocated.
The abstract step function, then, considers \emph{all} possible next states for \emph{any} exception type.

Furthermore, not all indirections are resolvable.
In these cases, we do not apply additional heuristics or guesses.
Instead, we stop further exploration at the indirection, if a jump, and clearly annotate the output accordingly.
Unresolved indirect calls are treated as unmodeled external calls, but the same principle applies.
We thus informally argue that the produced \ac{eicfg} is overapproximative \emph{modulo} unresolved indirections.
If the \ac{eicfg} is not annotated with any unresolved indirections, it is an overapproximation. % in the sense of \cref{def:simulation}.

\section{Graphs}
We have a specific node state for the \acp{eicfg} produced by our toolchain,
previously described in \cref{sec:eicfg}.
The graph node type $\node$ contains the following information:
The current program counter,
a list of the return addresses for all current stack frames,
the exception objects currently allocated,
the number of uncaught exceptions,
and the IDs of those exception objects currently caught.
The current jump table index and termination state will also included in this if they exist. In notation, this is
$\node\colon\pointer\times[\pointer]\times[\exception]\times\nat\times[\pointer]\times(\word|\bot)\times\termination$.
We further have a function $\stateToNode\colon\Sigma\rightarrow\node$
that maps from the more specific and detailed concolic states for execution
to the exceptional state for control flow representation.

\begin{definition}
  \begin{equation*}
    \stateToNode(r,s,\_,e,u,c,j,t,\_)=(
    \operatorname{rip}(r),
    \operatorname{retAddrs}(s),
    e,u,c,j,t
    )
  \end{equation*}
  Where $\operatorname{rip}$ gets the current \inlineasm{rip} from a register map and $\operatorname{retAddrs}$ extracts the list of return addresses from a stack.
\end{definition}
\begin{example}
  Again consider the instruction \inlineasm{133d:	jg     1362 <main+0x3d>}.
  The precondition for this instruction from \cref{ex:state} converts to
  \begin{equation*}
    (\mathtt{0x133d},[\mathtt{0x114e}],[],0,[],\bot,\bot),
  \end{equation*}
  which is what is shown in the \ac{eicfg} in full-detail mode.
  In basic block mode, performed via postprocessing of the \ac{eicfg}, we can have a range of addresses instead of a single address for the node state. For this specific case, the basic block node representation is
  \begin{equation*}
    ([\mathtt{0x1325},\mathtt{0x133d}],[\mathtt{0x114e}],[],0,[],\bot,\bot).
  \end{equation*}
\end{example}

The \acp{eicfg} themselves are represented in a slightly different form from that described in \cref{sec:eicfg}.
They consist of a set of nodes and a set of annotated edges that connect those nodes: $graph\colon\{\node\}\times\{\edge\}$.
The edge annotations are instructions for edges that follow standard control flow.

\begin{example}
  Consider the simple graph shown in \cref{fig:simple-graph}.
  This graph is the graph you would get after analyzing \cref{lst:start-first} of \cref{lst:example-start}.
  Mathematically, this graph has nodes
  \begin{align*}
    n_0 &= (\mathtt{0x1140},[],[],0,[],\bot,\bot) \\
    n_1 &= (\mathtt{0x1144},[],[],0,[],\bot,\bot)
  \end{align*}
  and edge $(n_0,n_1,\mathasm{endbr64})$.
\end{example}
\begin{figure}
  \centering
  \begin{tikzpicture}
    \graph[grow right=5cm,nodes=draw]{
      "Address: 0x1140" ->["\inlineasm{endbr64}"]
      "Address: 0x1144"
    };
  \end{tikzpicture}
  \caption{Simple Graph}
  \label{fig:simple-graph}
\end{figure}

\section{Summary}
\todo{maybe}
