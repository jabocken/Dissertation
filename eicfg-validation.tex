\chapter{Validation and Results}
\label{ch:eicfg-validation}

\section{Validation}
To increase trustworthiness, we validated some of our abstract transition rules against the corresponding real-world implementations. Specifically, we generated abstract states $\sigma$, and validated that:
\begin{equation}
    \sigma\absTransition\sigma'\land\gamma(\sigma)\concTransition s'\implies\alpha(s')=\sigma' \label{eq:validation}
\end{equation}
Here $\alpha$ and $\gamma$ denote abstraction and concretization functions, and $\concTransition$ denotes concrete execution.

Abstract states $\sigma$ are obtained through via \emph{fuzzing} \autocite{quickcheck}.
For each rule under validation, we generated \fuzzcount\ arbitrary initial abstract states ($\sigma$) and then applied the rule to obtain the corresponding abstract post states ($\sigma'$).
Then, using a test harness implemented as a combination of Python and GNU Project debugger (\href{https://www.sourceware.org/gdb/}{GDB}) scripts, we ran constructed real-world binaries featuring the desired concrete functions.
The usage of \acs{gdb} allowed easy interceding at specific points in the binaries in order to set up the initial state and extract the state after the step.
Function $\gamma$ operates before the concrete library function is executed, setting the state parts in \cref{tbl:validation} to their test case values.
Function $\alpha$ operates after the concrete library function is executed, extracting the listed state parts from the concrete program state.
The test harness then verifies that the abstracted state parts match the expected ones generated previously, satisfying \cref{eq:validation}.
\Cref{tbl:validation} shows our validation status.

\begin{table}
    \caption{Validated State Parts}
    \label{tbl:validation}
    \centering
    \begin{tabular}{lccccccc}
        \toprule
        \thead{Rule} & \thead{$\rip$} & \thead{in/out regs} & \thead{$\handlerCount$} & \thead{$\uncaught$} & \thead{$\mathsf{handlerSwitchValue}$} & \thead{$\caught$} \\
        \midrule
        \inlineasm{__cxa_throw} & \checked & \checked & \checked & \checked && \\
        \inlineasm{__cxa_begin_catch} & \checked & \checked & \checked & \checked & \checked & \\
        \inlineasm{__cxa_end_catch} & \checked & n/a & \checked & \checked & \checked & Partial \\
        \inlineasm{__cxa_rethrow} & \checked & \checked & \checked & \checked && Partial \\
        \inlineasm{_Unwind_Resume} && \checked & \checked & \checked & \checked & \\
        % \todo{\inlineasm{_Unwind_RaiseException}} &&&& \\ % we didn't provide an actual rule for this so no need to model!
        % \inlineasm{_Unwind_ForcedUnwind} &&&& \\
        % \inlineasm{_Unwind_GetIP} &&&& \\
        % \inlineasm{_Unwind_GetRegionStart} &&&& \\
        \bottomrule
    \end{tabular}
\end{table}

\subsection{Test Programs}
Our constructed test programs are designed to be minimal but still call the specific library functions we provided abstract transition rules for.
To easily read and write memory using \ac{gdb}, we provided dummy versions of certain structs.
Specifically, the hidden library structs for individual exception objects as well as global exception information.
To utilize those structs within \ac{gdb}, the programs must be built in debug mode.

\subsection{Abstract State Generation}
Next, the abstract start and end states are generated by a small wrapper around our abstract transition rules.
We used components of the property testing library QuickCheck \autocite{quickcheck} to instrument the start state generation.
The initial starting addresses are defined by the binary versions of the above-mentioned test programs.
The end state generation is performed by applying a single step of our methodology to those test programs using those start states.
The start states as well as the end states for each step are then exported for use by the test harness.

\subsection{Concretization and Abstraction}
The concretization and abstraction functions~$\gamma$ and~$\alpha$ are part of that test harness.
As in abstract interpretation, they interface between the generated abstract states and the concrete memory layouts mentioned above.
Both functions operate via \ac{gdb} breakpoints that are set depending on the rule under test.
$\gamma$ operates before the concrete library function is executed, setting the state parts in \cref{tbl:validation} to their test case values.
$\alpha$ operates after the concrete library function is executed, extracting the listed state parts from the concrete program state after the library function is executed.
The test harness then verifies that the abstracted end state parts match the expected ones generated previously, satisfying \cref{eq:validation}.

\section{Results}\label{eicfg-results}
Here we present the results of generating \acp{eicfg} for \totalbins\ real-world programs and libraries.
These programs and libraries have a variety of sizes and use cases and were sourced from places like GitHub and the \ac{apt} repositories.
\exceptbins\ of these programs utilize \Cpp\ exception handling (several despite the lack of exception handling tables) while all have been compiled for the \gls{arch} \ac{isa} and the System~V \ac{abi}.
%\strippedbins\ of the binaries were stripped of symbols.
The \ac{eicfg} generation for each binary was executed on a server with four Intel\textregistered\ Xeon\textregistered\ E7-8890v4 \acp{cpu} (for a total of 96 cores) running at \SI{2.20}{\giga\hertz} with \SI{252}{\gibi\byte} of \ac{ram}.
The server's \ac{os} was Ubuntu 18.04.5 \ac{lts}.
Execution timeout was set to eight hours. % for openmw thing but also some of the Xen
Some of the numbers were collected with the assistance of GNU\index{GNU} parallel \autocite{Tange2011a}.

A summary of the results comparing \ac{eicfg} generation to our tool with exception handling disabled can be found in \cref{tbl:binaries}.
That baseline version functions as our regular tool but without the unwinding-related abstract transition rules from \cref{fig:unwind,fig:step-rules1,fig:step-rules2}. Specifically, the throw-related functions (such as \inlineasm{__cxa_throw}) were treated as terminating functions while the catch-related functions (such as \inlineasm{__cxa_begin_catch}) were treated as no-ops.
25 of the binaries we analyzed are not included in the table as the tool ran out of of memory or timed out due to state space explosion, in one case just in the baseline version.

\begin{table}
    \centering
    % \begin{threeparttable}
        \caption{Case study results.}\label{tbl:binaries} %  (Failures at the Bottom)
        \begin{tabular}{l
                r% S[table-format=3]
                S[table-format=7] % total inst count
                S[table-format=7]
                S[table-format=4]
                S[table-format=4]
                %            S[table-format=4] % leaving out resolved jumps/calls as we need more space
                %            S[table-format=3]
                %            S[table-format=5] % leaving out unresolved jumps/calls as we need more space
                %            S[table-format=4]
                S[table-format=6.0]
                |
                S[table-format=5] % inst coverage differential
                %            S[table-format=-7] % regular edge coverage differential
            }
            \toprule
            % Leaving out binary stripped status here as there's no room for it anyway
            % Also leaving out explicit covered count as that can be derived from the %; can always add back in later.
            %            {Groups} & {Count} & {Insts.\tnote\dag} & {Full Cov./\%} & {Baseline Cov./\%} & {Nodes} & {Edges} & {Unw.} & {Unique Thr.} & {Caught Thr.} & {$w$\tnote\ddag} & {$x$} & {Time/\si{\second}} \\
            & \multicolumn{6}{c}{\thead{Absolute Numbers}} & {\thead{Baseline\\Comparison}} \\
            \midrule
            {\thead{Groups}} & {\thead{Binary\\Count}} & {\thead{Covered\\Insts}} & {\thead{Unwind\\Edges}} & {\thead{Unique\\Throws}} & {\thead{Caught\\Throws}} & {\thead{Time/\si\second}} & {\thead{Inst Diff}} \\ % {\thead{Edge\\Diff}}
            \midrule
            NASA & 13/14 & 1741089 & 1410 & 167 & 136 & 8276 & 1027 \\
            Xen & 85/90 & 231880 & 0 & 0 & 0 & 32200 & 0 \\
            Magick & 15/17 & 172811 & 14 & 14 & 2 & 129 & 15 \\
            Cups & 163/164 & 317137 & 3938 & 33 & 0 & 6811 & -9 \\
            Other & 18/23 & 763063 & 63260 & 830 & 526 & 9324 & 11766 \\
            caf & 5/6 & 632127 & 7952 & 466 & 254 & 1767 & 4251\\
            art & 1/4 & 57866 & 216 & 31 & 30 & 264 & 1885 \\
            audio & 5/7 & 100207 & 49199 & 523 & 380 & 1153 & 8509 \\
            drives & 3/3 & 5470 & 21538 & 31 & 30 & 411 & 353 \\
            games & 4/7 & 117375 & 735224 & 519 & 473 & 19560 & 5551 \\
            science & 1/1 & 23804 & 3567 & 94 & 92 & 80 & 3009 \\
            tasking & 1/1 & 23977 & 6 & 4 & 3 & 646 & 119 \\
            torrent & 2/5 & 512095 & 383180 & 600 & 399 & 25122 & 8235 \\
            \addlinespace
            Totals & 316/341 & 4715806 & 1269649 & 3350 & 2356 & 105809 & 45032 \\
            \bottomrule
        \end{tabular}
        % \begin{tablenotes}
            %     \item[\dag] An approximation; the non-empty line count of output from \texttt{objdump}.
            %     \item[\ddag] $w=\text{Unresolved Calls}$, $x=\text{Unresolved Jumps}$%, $y=\text{Unresolved Calls}$, $z=\text{Unresolved Jumps}$
            % \end{tablenotes}
        % \end{threeparttable}
\end{table}

We identified \uniquethrows\ unique throws and traced the exceptional control flow of each one.
Based on our analysis, we were able to identify \uncaughtthrows\ of them as uncaught; the remaining \caughtthrows\ all had a potential catch block in their unwinding path.
On average, dealing with exceptional control flow can increase coverage by \avgdiffinst\ per unique throw, with each throw averaging \avgunwinds\ unwind edges.
Those edges are ones tools such as Ghidra do not produce.
Note the Xen binaries exhibited no change, as none contained any exceptional control flow.

% TODO: Maybe leave out coverage talk for this, I think it might still be useful to discuss though to provide inspiration for future endeavors.
\subsection{Coverage} % Freek's not a fan of the subsections due to having too few paragraphs each. Personally I like them as you can get a detailed overview from the table of contents though.
% In total, we achieved an average of \coveredpercent\ coverage of the counted instructions across the \satisfactorybins\ satisfactory (\cutoffpercent\ coverage) binaries.
% Ideally, this number would be the ratio of reached instructions to actual reachable instructions.
% However, we do not have a ground truth for the latter number. Therefore, we approximate by comparing the number of reached instructions with the raw line count provided by \inlineasm{objdump}. This ratio gives an \emph{indication} of how much of each binary was covered.

% The coverage was achieved in several steps for each binary.
% First, we started \ac{eicfg} generation from the address recorded in the \ac{elf} entry field.
% Then we checked the binary's list of function symbols, if available, and used each one as a further entry point if not already in the graph.
% This can cause issues for some stripped binaries with unresolved indirect jumps, but not all; 77 stripped binaries were satisfactory, and of those 19 exhibited unresolved jumps.
% Additional coverage was provided by modeling external functions that were identified as taking direct function pointers as callbacks by treating them as calls to the callbacks.
% This includes thread-spawning functions such as \inlineasm{pthread_create}, though we do not model their concurrent behavior.

% Commenting out for TACAS as I removed the corresponding columns anyway
\subsection{Indirection}\label{sec:indirection}
% Concerning unresolved calls and jumps specifically,
% the count of those in \cref{tbl:binaries} is primarily due to symbolic callbacks and other passed-around jump targets that cannot be concretized after our abstraction.
% However, many instances of indirection \emph{were} resolvable, though excluded from the results table due to space constraints.
% Those cases rely on a non-deterministic heuristic for basic jump table calculations,
% %which is documented in \cref{sec:example}
% which is documented in \cref{sec:eicfg}
% for the example \ac{eicfg} and corresponding code snippet in \cref{fig:example-indirect-call,lst:example-indirect-call}.

% Because not all calculations involving a static upper bound are jump table calculations, this heuristic can be tuned in order to control state space expansion.
% When the \ac{eicfg} generation algorithm is supplied with a specific \ac{jtub},
% predicted jump table index locations with bounds greater than that \ac{jtub} will fall back to normal state read handling.
% This does not affect our overapproximation, as it results in annotated \acp{eicfg}, but may reduce coverage.
% For the specific results displayed in \cref{tbl:binaries}, we utilized \iac{jtub} of 25.
%Our results showed that using that limit did not significantly reduce reported instruction coverage and did increase binary coverage overall.

%% Hiding most of it as it does comparisons to numbers we do not actually show. Might have room to show them in my dissertation, though!
\subsection{State Space Reduction}
%As our approach is context-sensitive where possible, this resulted in significantly more \ac{eicfg} nodes than instructions.
%Specifically, we generate an average of over thirty graph nodes per instruction.
%To prevent further state space explosion and reduce performance issues we encountered, we implemented some state space reduction measures.

%% Freek felt this paragraph muddled the explanation of rules. Would like to do comparative graphs/tables in my dissertation to show the coverage changes, though!
% For the first such measure, our analysis tool has an option to reduce the exceptional state space by simplifying the rules in \cref{fig:step-rules1,fig:step-rules2}.
% Specifically, it removes usage of $\emap$, $\caught$, and $\uncaught$, instead assuming the existence of correct behavior regarding those fields.
% This did not reduce instruction coverage in any of our successful tests and allowed more analyses to complete without timing out or running out of memory.
% % volk_profile, audiowaveform
% In fact, for some programs, such as \inlineasm{transmission-edit} and \inlineasm{AntSimulator}, it slightly increased coverage.
% % transmission-edit had decreased node count but AntSimulator increased.

%A further reduction technique was to restrict assumed \acp{JTUB}.
%Cases with bounds greater than a user-supplied value can be instructed to fall back to normal rather than \ac{JTUB} handling.
%This is
%Thus, using an unbounded upper bound can result in a significant number of unnecessarily-generated graph nodes.

\subsection{Failures}
% The 144 binaries that had unsatisfactory analyses can be split up into four categories.
% 12 ran out of of memory or timed out due to state space explosion.
% 85 were stripped binaries with no unresolved indirect calls or jumps.
% Our examination has indicated that the most likely cause of failure in such a scenario is external or internal function calls that receive callbacks our potential-callback detection mechanism cannot identify, such as non-immediate values and the like.
% 27 of the unsatisfactory stripped binaries do feature unresolved calls or jumps, indicating another potential failure point.
% The final 20 unsatisfactory binaries are not stripped but still exhibit some amount of unresolved calls or jumps.
% This illustrates that even for non-stripped binaries with function symbols available, full internal coverage requires resolved indirections.

\section{Challenges}
\todo\dots

\subsection{For Validation}
During the process of validation, we uncovered several implementation quirks that were not obvious.
For example, the field $\handlerCount$ is actually a signed integer.
This means that, when generating initial states, a negative value may be produced.
As it turns out, the concrete implementation of \inlineasm{__cxa_begin_catch} takes the absolute value of negative handler counts supplied to it before incrementing that value.
\inlineasm{__cxa_rethrow} performs a similar, but stranger, transformation.
It decreases the magnitude by one, then inverts the sign; if the magnitude is 0, $\handlerCount$ is unchanged.
The implementation of our abstract transition rules was updated to reflect those unearthed quirks.

Additionally, some issues arose when constructing arbitrary concrete states.
For example, creating arbitrary exception objects requires explicitly allocating memory, as modern real-world programs have memory protection and do not allow accessing unallocated memory locations.
Thus, we did not perform fuzzing with the \inlineasm{exceptionType} field, nor did we do a full analysis of the $\caught$ linked list and the necessary \inlineasm{nextException} field.
Rethrown status is not dealt with here as well as in concrete implementations it is not explicitly part of the exception object header struct or the global exceptional state.

We also did not cover those cases where an exception does not get caught and results in program termination due to stack unwinding.
This is because we were unable to easily check the desired state parts in such cases.
Similarly, we could not validate the $\rip$ modification of \inlineasm{_Unwind_Resume}.
When running in \ac{gdb} with our test program constructed to utilize \inlineasm{_Unwind_Resume}, handler switch value manipulation is required to trigger that path.
That in itself is not necessarily an issue, but when that path is taken, control flow is ultimately redirected to the landing pad for the catch block that leads to the \inlineasm{_Unwind_Resume} rather than an appropriate parent landing pad.
This prevents us from validating the target landing pad (or lack thereof) for that function (i.e.\ $\sigma'.\rip$).
However, we were still able to validate the other exceptional state components manipulated by that function.

\subsection{For Integration Concerns}
During comparative analysis, we discovered that termination states provided excess overapproximation.
Specifically, two of the cups binaries, which both throw exceptions, have slightly more covered instructions in the baseline (\inlineasm{pdftohtml} and \inlineasm{pdftocairo}).
This appears to be related to the usage of specific C++ functions that wrap exception throwing such as \lstinline{std::__throw_logic_error(char const*)}, which are treated as terminating in the baseline.
The ``missing'' instructions are the ones immediately following those calls.
This indicates that the instruction after a terminating function call is included in the set of covered instructions, a minor flaw of our overapproximation.
% while in general coverage and control flow graph nodes/edges did increase when using \acp{eicfg}, some programs from the games category exhibited a reduced state space and improved analysis performance. A decrease in state space and even coverage also occurred for some cups (printing/document conversion-related) binaries.
% The game and cups state space reduction is likely due how our overapproximative technique's join operation and function symbol heuristic interact with deeply nested call trees to reduce contextual state in the presence of long unwinding chains.

\todo{explain fix}

\section{Summary}
\todo{maybe}
